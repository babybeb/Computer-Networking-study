# 전송 계층

# 전송 단위

전송 계층의 TCP/UDP의 전송 단위는 세그먼트이다.

참고) 애플리케이션 계층의 HTTP의 전송 단위는 메시지이다.

<br>

# **멀티플렉싱과 디멀티플렉싱**

## Multiplexing(다중화)

출발지 호스트의 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업

즉, **송신 측 프로세스의 소켓 → 송신 측 트랜스포트 계층의 세그먼트**로의 변환 과정이다. 이를 우편 배달로 비유하면, 한 우체국에서 여러 종류의 우편을 접수받아 형식을 통일하여 집배원에게 넘겨주는 것과 비슷하다.

## Demultiplexing(역다중화)

트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업

이를 우편 배달로 비유하면, 집배원이 한 가정에 여러 건의 우편을 배달했을 때, 그 가정 안에서 우편물이 누구한테 온 것인지를 살펴보고 각각의 구성원에게 전달하는 것과 비슷하다.

## 비연결형 다중화와 역다중화(UDP)

**목적지 IP 주소와 목적지 포트 번호**만 가지고 식별한다.

## 연결지향형 다중화와 역다중화(TCP)

**출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호**를 가지고 식별한다.

<aside>
💡 애플리케이션 계층에서 설명한 것과 달리, 사실 각 소켓은 고유의 포트 번호를 갖지 않는다. TCP 소켓들은 고유의 포트 번호 대신 고유의 ID를 가진다. 이 고유 ID는 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호로 이루어진다. 즉, 네 가지 중 하나만 달라도 다른 소켓으로 구분된다.

</aside>

<br>

# UDP

UDP의 세그먼트 구조는 **출발지 포트 번호, 목적지 포트 번호, 길이, 체크섬, 애플리케이션 데이터**로 이루어져 있다.

### 특징

- 비연결성, 비신뢰성
- Checksum을 통한 오류 검사 제공 → 오류를 회복하기 위한 일은 하지 않는다.
**유실되는 데이터**가 있을지언정, 엉뚱한 데이터가 날라가진 않는다.

<br>

# 신뢰성 있는 데이터 전송의 원리

### Network 계층을 신뢰할 수 없기 때문에 전송 계층에서 만든 장치
== 신뢰적인 데이터 전송 메커니즘

| 체크섬 | 전송된 패킷 안의 비트 오류를 발견하는 데 사용된다. |
| --- | --- |
| 타이머 | 채널 안에서 패킷이 손실되었기 때문에 발생하는 패킷의 타임아웃/재전송에 사용된다. |
| 순서 번호 | 송신자에서 수신자로 가는 데이터 패킷의 순서벝호를 붙이기 위해서 사용된다. 수신자 패킷의 순서번호의 격차는 수신자로 하여금 손실된 패킷을 검사하게 한다. 중복된 순서번호를 갖는 패킷은 수신자로 하여금 패킷의 중복 복사를 검사하게 한다. |
| 확인 응답 | 송신자에게 패킷 또는 집합이 정확히 수신되었다는 응답을 하기 위해 수신자가 보낸다. |
| 부정 확인 응답 | 송신자에게 패킷 또는 집합이 정확히 수신되지 않았다는 응답을 하기 위해 수신자가 보낸다. |
| 윈도우, 파이프라이닝 | 송신자는 주어진 범위에 있는 순서번호를 가진 패킷만 전송하도록 제한될 수 있다. |

## Simple Protocol(rdt 1.0)

- `흐름 제어`나 `오류 제어`가 없는 단순한 전송 계층 프로토콜
- 이 프로토콜에서는 수신 측이 수신한 패킷을 즉시 처리할 수 있다고 가정한다.
- 송신 측은 수신 측의 상태를 고려하지 않는다.

## Stop-and-Wait Protocol

- `흐름 제어`와 `오류 제어`를 모두 사용하는 연결 지향 프로토콜
- 송신 측과 수신 측은 모두 **크기가 1**인 **`슬라이딩 윈도우`**를 사용한다.
- 송신 측은 한 번에 하나의 패킷을 전송하고 확인 응답이 들어오기 전까지는 다음 패킷을 전송하지 않는다.
- 패킷이 손상되었는지를 검사하기 위해 각각의 데이터 패킷에 `체크섬` 추가
- 패킷을 중복 수신하지 않도록 `순서 번호`와 `확인 응답` 사용

### Stop-and-Wait Protocol 실행 순서

1. 패킷이 오류 없이 안전하게 수신측에 도착하면, 수신측은 `확인 응답`을 전송한다. 만약 패킷이 훼손되어 수신측에 도착하지 않았다면, 송신측은 `타임 아웃` 후에 패킷을 재전송한다.
2. 수신측이 보낸 `확인 응답`이 송신측에 도착하면, 송신측은 x+1의 순서 번호를 갖는 다음 패킷을 전송한다.
3. 패킷이 오류 없이 안전하게 수신측에 도착하면, 수신측은 `확인 응답`을 전송한다. 만약 이 `확인 응답`이 훼손되거나 손실되었다면 송신측은 타임 아웃 후에 패킷을 재전송한다. 이렇게 재전송된 패킷은 중복 패킷이다. 수신측에서 x+1 순서 번호 패킷의 수신을 기대했는데 x 순서 번호 패킷을 수신했기 때문이다.

즉, 송신측→ 수신측 패킷 전송이 잘 되었는지는 `타이머`를 사용하여 일정 시간 안에 수신측에서 보낸 `확인 응답`이 송신측에 잘 도착했는지를 통해 알 수 있다. 만약 타이머 시간 안에 확인 응답이 도착하지 않았다면 송신 측은 타임 아웃으로 간주하고 패킷을 재전송한다.

`타임 아웃`은 송신측→ 수신측 패킷이 제대로 도착하지 않을 경우, **수신측→ 송신측 `확인 응답`이 제대로 도착하지 않을 경우**에 발생한다. 결국 송신측→ 수신측 패킷이 제대로 도착하지 않은 경우에도 수신측→ 송신측 `확인 응답`이 제대로 도착하지 않게 된다.

### Stop-and-Wait 프로토콜의 예

## Go-Back-N Protocol

- 전송 효율을 향상시키기 위한 프로토콜로, 확인 응답을 기다리는 동안에 여러 개의 패킷을 전송할 수 있다.
- m: 순서 번호 필드의 비트 수
- `순서 번호`를 사용한다. 순서 번호는 `2^m`이다.
- `송신 슬라이딩 윈도우`와 `수신 슬라이딩 윈도우`를 사용한다.
    - 송신 윈도우
        - 전송 중이거나 전송될 데이터 패킷의 순서 번호를 포함하는 가상의 상자
        - 송신 윈도우의 최대 크기: `(2^m)-1`
    - 수신 윈도우
        - 올바른 데이터 패킷을 수신하고 올바른 확인 응답이 전송될 수 있도록 한다.
        - 수신 윈도우의 크기: 항상 1 → 순서대로 도착하지 않은 패킷은 수용 불가하다.
- `**타이머`와 `패킷 재전송`을 사용한다. 전송되는 각 패킷마다 타이머가 있고, 첫 번째 타이머가 만료되면 모든 미해결 패킷을 재전송한다.**
    

<aside>
💡 **Stop-and-Wait와 Go-Back-N 비교**
Stop-and-Wait 프로토콜은 m=1, modulo=2인 Go-Back-N 프로토콜이다.

</aside>

## Selective Repeat Protocol

### Go-Back-N 프로토콜의 문제점

타임 아웃이 일어날 경우, 수신 측의 버퍼가 1개이기 때문에, 확인 응답을 받지 못한 가장 과거 패킷 번호까지 되돌아가서 **모든 미해결 패킷을 `재전송`한다.**

**→ 패킷을 잘못 보냈을 때 `재전송 부담`이 매우 크다.**

### Selective Repeat Protocol의 특징

- **손실된 패킷만을 선택적으로 `재전송`한다.**
- 모든 패킷에 대한 타이머를 관리해야 하므로 비용이 크고, 알고리즘이 복잡하다.
- 송신 윈도우와 수신 윈도우가 있으며, Go-Back-N 프로토콜의 윈도우와는 차이가 있다.
    - 송신 슬라이딩 윈도우
        - 크기: 순서 번호의 크기가 `2^m`인 데 반해, 슬라이딩 윈도우의 크기는 `2^(m-1)`로 작다.
        - 수신 윈도우와 크기가 같다.
    - 수신 슬라이딩 윈도우
        - 송신 윈도우와 크기가 같다.
        - 수신 윈도우의 크기만큼 많은 패킷들이 순서에 맞지 않게 도착한다면 남은 패킷들은 버퍼에 저장한다. → 송신 윈도우와 수신 윈도우의 크기가 같기 때문에 모든 패킷들이 순서에 맞지 않게 도착해도 된다.
        - 순서에 맞게 도착한 패킷만 응용 계층으로 전달한다.

<aside>
💡 **Go Back N과 Selective Repeat 비교**

`타이머`와 `확인 응답` 측면에서 볼 수 있다.
`타이머` 측면에서 보면, Go Back N에서는 처리되지 않은 패킷을 그룹으로 처리하고, Selective Repeat에서는 독립적으로 처리한다. 즉, Selective Repeat에서는 아직 처리되지 않은 각각의 패킷마다 각각 타이머를 사용한다.
`확인 응답` 측면에서 보면, Go Back N에서의 패킷 순서 번호는 누적이며, 해당 번호 이전의 모든 패킷들은 이상적으로 도착했음을 의미한다. Selective Repeat에서의 패킷 순서 번호는 오류 없이 처리된 하나의 패킷 순서 번호이다.
****

</aside>

# TCP

참고: [패킷의 흐름과 오류를 제어하는 TCP](https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/), [TCP 의 흐름 제어 / 오류 제어 / 혼잡 제어](https://benlee73.tistory.com/186), [TCP/IP 흐름제어와 혼잡제어](https://hammii.tistory.com/m/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPIP-%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%EC%99%80-%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4), [3 way handshake & 4 way handshake](https://gyoogle.dev/blog/computer-science/network/TCP%203%20way%20handshake%20&%204%20way%20handshake.html)

- 연결 지향 방식→ 패킷을 전송하기 위한 논리적 경로 배정(가상 회선 방식, 3-way handshaking)
    - 3-way handshaking 과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 높은 신뢰성 보장→ 흐름 제어, 혼잡 제어 활용 → `[Stop and Wait](https://www.notion.so/9d14829591644c75acb641f242a44399)`, `[Go Back N](https://www.notion.so/9d14829591644c75acb641f242a44399)`, `[Selective Repeat](https://www.notion.so/9d14829591644c75acb641f242a44399)` 방식 존재
- 흐름 제어, 오류 제어, 혼잡 제어
- UDP보다 속도가 느리다.

<br>

## 흐름 제어

### 필요한 이유

송신 측과 수신 측이 서로 데이터를 주고 받을 때, 여러 요인에 따라 송수신 측의 처리 속도가 달라질 수 있다. 이 때 수신 측의 처리 속도가 송신 측보다 빠른 경우에는 문제가 없다. 그러나 **수신 측의 처리 속도보다 송신 측의 처리 속도가 더 빠른 경우 문제가 생긴다.**

**수신 측이 자신의 버퍼 안에 있는 데이터를 처리하는 속도보다 송신 측이 데이터를 전송하는 속도가 더 빠르다면, 당연히 수신 측의 버퍼는 언젠가 꽉 차버리게 된다.**

이러한 문제를 해결하기 위해 송신 측은 수신 측의 데이터 처리 속도를 파악하고 자신이 얼마나 빠르게, 많은 데이터를 전송할 지 결정해야 한다. → 흐름 제어

### 하는 방법

`슬라이딩 윈도우`를 활용한다. → `[Stop and Wait](https://www.notion.so/9d14829591644c75acb641f242a44399)`, `[Go Back N](https://www.notion.so/9d14829591644c75acb641f242a44399)`, `[Selective Repeat](https://www.notion.so/9d14829591644c75acb641f242a44399)`** 방식 해당

### 슬라이딩 윈도우

자신이 처리할 수 있는 데이터의 양을 의미하는 윈도우 크기를 자신의 응답 헤더에 담아서 송신 측에게 전해주게 되고, 송신 측은 상대방에게 데이터를 보낼 때 이 윈도우 크기와 네트워크의 현재 상황을 참고해서 알맞은 양의 데이터를 보냄으로써 전체적인 데이터의 흐름을 제어하게 된다.

## 오류 제어

`체크섬`, `타이머`, `확인 응답`, `순서 번호`을 활용한다.

`재전송`을 활용한다. → `[Stop and Wait](https://www.notion.so/9d14829591644c75acb641f242a44399)`, `[Go Back N](https://www.notion.so/9d14829591644c75acb641f242a44399)`, `[Selective Repeat](https://www.notion.so/9d14829591644c75acb641f242a44399)`** 방식 해당

### 재전송

통신 중에 뭔가 오류가 발생하면 송신 측이 수신 측에게 해당 데이터를 다시 전송한다. 재전송 방식은 기본적으로, 했던 일을 다시 하는 작업이기 때문에 비효율적이다. 때문에 재전송 과정을 최대한 줄일 수 있는 여러 가지 방법을 사용한다.

오류가 발생했다는 사실은 `타임 아웃`을 통해 알 수 있다. 송신 측에서 보내는 패킷마다 타이머를 달아, 타이머가 종료되기 이전에 수신 측으로부터 ACK을 받지 못한 경우에 `타임 아웃`이 일어난다.

`타임 아웃`이 일어나는 경우는 수신 측이 아예 데이터를 받지 못해 ACK을 보내지도 못했거나, 수신 측에서는 제대로 응답했으나 해당 ACK 패킷이 유실된 경우이다.

<br>

## 혼잡 제어

- 네트워크 내의 패킷의 수가 과도하게 증가하는 현상인 혼잡 현상을 방지하고 제거하기 위해 사용한다.
- 라우터를 포함한 넓은 범위의 전송 문제를 다룬다.

### ****AIMD (Additive Increase / Multiplicative Decrease)****

- 처음에 패킷을 하나씩 보내고 문제가 발생하지 않으면 윈도우 크기를 1씩 증가시킨다.
- 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷 전송 속도를 절반으로 줄인다.
- 네트워크에 늦게 들어온 호스트가 처음에는 불리하지만, 시간이 흐르면서 평행 상태로 수렴한다.
- 처음에 전송 속도를 올리는 데 시간이 오래 걸린다.
- 네트워크가 혼잡해지는 상황을 미리 감지하지 못하기 때문에, 네트워크가 혼잡해지고 나서야 대역폭을 줄인다.

### 느린 시작(Slow Start)

- AIMD와 같이 패킷을 하나씩 보내고 문제가 발생하지 않으면 윈도우 크기를 1씩 증가시킨다. 즉, 한 주기가 지나면 윈도우 크기는 2배가 된다.
- AIMD와 달리 전송 속도를 지수 함수 꼴로 증가시켜서 윈도우 크기를 더 빠르게 증식시킨다.
- 혼잡이 감지되면 윈도우 크기를 1로 줄인다.
- 처음에는 네트워크 수용량을 예상할 수 있는 정보가 없지만, 한 번 혼잡 현상이 발생한 후에는 네트워크의 수용량을 어느 정도 예상할 수 있다.
- 혼잡 현상이 발생하는 윈도우 크기의 절반까지 → 지수 함수 꼴로 윈도우 크기를 증가시킨다.
- 그 이후 → 윈도우 크기를 완만하게 1씩 증가시킨다.

### 빠른 재전송(****Fast Retransmit****)

- timeout이 발생하기 전이라도 문제가 되는 패킷이 있다면 재전송하고, 혼잡한 상황이라고 판단하여 윈도우 크기를 줄인다.

### 빠른 회복

- 혼잡한 상태가 되면 윈도우를 반으로 줄이고, 선형 증가시킨다.
- 혼잡 상황을 한 번 겪은 이후로는 AIMD 방식으로 동작한다.

<br>

## 3 WAY HANDSHAKING

TCP의 논리적인 연결 성립 시 진행한다.

1. 클라이언트가 서버에게 SYN 패킷을 보낸다.
2. 서버가 SYN 패킷을 받고 받았다는 신호인 ACK과 SYN 패킷을 보낸다.
3. 클라이언트는 ACK과 SYN 패킷을 받고 ACK을 서버로 보낸다.

## 4 WAY HANDSHAKING

TCP의 논리적인 연결을 해제할 때 진행한다.

1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.
2. 서버는 FIN을 받고, 확인했다는 ACK을 클라이언트에게 보낸다. 이 때, 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다.
3. 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.
4. 클라이언트는 FIN을 받고, 확인했다는 ACK을 서버에게 보낸다. 이 때, 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT를 통해 기다린다.
5. 서버는 ACK을 받은 후 소켓을 닫고, 클라이언트는 TIME_WAIT 시간이 끝나면 소켓을 닫는다.

<br>

<aside>

**TCP VS UDP**

참고: [TCP와 UDP의 특징과 차이](https://mangkyu.tistory.com/15)

|  | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결형 서비스 | 비연결형 서비스 |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식 |
| 전송 순서 | 전송 순서 보장 | 전송 순서가 바뀔 수 있다 |
| 수신 여부 확인 | 수신 여부를 확인한다 | 수신 여부를 확인하지 않는다 |
| 통신 방식 | 1:1 통신 | 1:1 OR 1:N OR N:N 통신 |
| 신뢰성 | 높다 | 낮다 |
| 속도 | 느리다 | 빠르다 |
</aside>

<br>

### 질문 목록

<br>

- 연결지향형 다중화와 역다중화, 즉 TCP에서 다중화와 역다중화를 수행할 때, 각 소켓은 무얼로 구분하나요?
    
    출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호로 식별합니다.
    
<br>
<br>

- UDP는 오류 검사를 제공합니다. 이건 UDP 세그먼트의 어느 부분에 의해 수행되나요?
    
    Checksum
    
- 그렇다면, UDP는 오류를 검사한 후 회복하기 위한 작업을 하나요?
    
    하지 않습니다.
    
<br>
<br>

- TCP가 무엇인가요?
    
    두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 네트워크 프로토콜입니다. `흐름 제어, 오류 제어, 혼잡 제어`를 하고 `높은 신뢰성`을 가집니다. 또한 `연결 지향 방식`이기 때문에 `3 Way Handshaking`을 통해 연결을 설정합니다. 이로 인해 `느린 속도`를 가집니다.
    
- TCP는 높은 신뢰성을 보장한다는 특징이 있습니다. 이것을 위해 어떤 방식이 사용되나요?
    
    흐름 제어와 오류 제어를 사용합니다.
    
- 그렇다면 흐름 제어와 오류 제어를 보장하는 프로토콜의 대표적인 세 가지에는 무엇이 있나요?
    
    Stop and Wait, Go Back N, Selective Repeat
    
- Stop and Wait 프로토콜보다 Go Back N 프로토콜이 나은 점이 뭘까요?
    
    송신 측 관점에서, Stop and Wait 프로토콜은 수신 측의 확인 응답을 기다리는 동안 새로운 패킷을 전송할 수 없습니다. 하지만 Go Back N 프로토콜은 확인 응답을 기다리는 동안 여러 개의 패킷을 전송할 수 있습니다.
    
- Go Back N 프로토콜보다 Selective Repeat 프로토콜이 나은 점이 뭘까요?
    
    Go Back N은 타임 아웃이 일어날 경우, 수신 측의 버퍼가 1개이기 때문에, 확인 응답을 받지 못한 가장 과거 패킷 번호까지 되돌아가서 모든 미해결 패킷을 재전송해야 해서 재전송 부담이 큽니다. Selective Repeat는 미해결 패킷 하나만 재전송하면 되기 때문에 재전송 부담이 적습니다.