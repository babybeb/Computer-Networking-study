# 트랜스포트 계층

## 트랜스포트 계층 서비스 및 개요

트랜스포트 계층은 서로 다른 호스트에서 동작하는 애플리케이션 프로세스들 간의 `논리적 통신` 을 제공한다.

트랜스포트 계층 프로토콜은 종단 시스템에서 구현된다.

송신 측의 트랜스포트 계층은 송신 애플리케이션 프로세스로부터 받은 데이터를 세그먼트로 변환한다.

이러한 변환은 애플리케이션 메시지를 작은 조각으로 나누고, 각각아 조각에 헤더를 추가함으로써 수행 됨.

그 후에 네트워크 계층으로 세그먼트를 전달하고,

여기서 세그먼트가 패킷 안에 캡슐화 되어 목적지로 전달된다.

> 호스트 : 인터넷(네트워크)가 연결된 컴퓨터

> 논리적 통신 : 애플리케이션 관점에서 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보이는것을 의미

> 종단 시스템 : 호스트

> 세그먼트 : 트랜스포트 계층에서 사용하는 데이터의 단위

> 패킷 : 네트워크 계층에서 사용하는 데이터 단위

<br />
<br />

## 인터넷 트랜스포트 계층의 개요

인터넷은 애플리케이션 계층에게 두 개의 트랜스포트 계층 프로토콜을 제공한다.

- UDP(User Datagram Protocol) : 비신뢰적, 비연결형인 서비스를 제공
- TCP(Transmission Control Protocol) : 신뢰적이고 연결지향형 서비스를 제공

인터넷의 네트워크 계층 프로토콜은 `인터넷 프로토콜` 줄여서 IP 라고 한다.

IP 서비스 모델은 호스트들 간에 논리적 통신을 제공하는 <b>최선형 전달 서비스(best-effort delivery service)</b> 이다.

IP는 세그먼트의 전달을 보장하지 않고, 순서대로 전달되는 것을 보장하지 않는다.

또한 세그먼트 내부 `데이터의 무결성(integrity)` 을 보장하지 않는다.

이런 특성 때문에 IP는 `비신뢰적인 서비스(unreliable service)` 라고 부른다.

> 최선형 전달 서비스(best-effort delivery service) : IP가 통신하는 호스트들 간에 세그먼트를 전달하기 위해서 노력하지만, 어떠한 보장도 하지 않는다.

UDP와 TCP는 종단 시스템 사이의 IP 전달 서비스를 종단 시스템 위에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것이다.

<b>호스트 - 호스트</b> 전달을 <b>프로세스 - 프로세스</b> 전달로 확장하는 것을 `트랜스포트 다중화(transport multiplexing)` 와 `역다중화(demultiplexing)` 이라고 부른다.

<br />
<br />

## 다중화와 역다중화

트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 데이터를 전달하는 의무를 가진다.

트랜스포트 계층은 데이터를 소켓에게 전달하는데

하나 이상의 소켓이 있을 수 있으므로, 각각의 소켓은 유일한 식별자를 가진다.

식별자의 포맷은 UDP 소켓인지 TCP 소켓인지에 따라 달라진다.

- 출발지 호스트에서 소켓으로부터 데이터를 모으고, 각 데이터에 헤더정보로 캡슐화하고, 그렇게 만든 세그먼트들을 네트워크 계층으로 전달하는 작업을 `다중화(multiplexing)` 이라 한다.

- 목적지 호스트의 트랜스포트 계층에서 전달받은 세그먼트를 검사하고 올바른 소켓으로 전달하는 작업을 `역다중화(demultiplexing)` 이라 한다.

### 비연결형 다중화와 역다중화(UDP)

- 출발지와 목적지의 포트번호만 가지고 식별한다.

### 연결지향형 다중화와 역다중화(TCP)

- 출발지 IP주소, 포트번호, 목적지 IP주소, 포트번호를 가지고 식별한다.

<br />
<br />

## UDP

UDP는 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작한다.

UDP는 다중화/역다중화와 오류 검사 기능만 수행한다.

UDP는 세그먼트를 송신하기전에 핸드셰이크를 하지 않기 때문에 <b>비연결형</b> 이라고 한다.

- 연결 설정이 없다.

  TCP는 three-way-handshake 를 사용하지만 UDP는 사전준비 없이 전송한다. 연결을 설정하기 위한 어떤 지연도 없다.

- 연결 상태가 없다.

  TCP는 종단 시스템에서 연결 상태를 유지하고, 이 연결 상태는 수신 버퍼와 송신 버퍼, 혼잡 제어 파라미터, 순서 번호와 확인응답 번호를 포함하고 이 상태 정보가 TCP의 신뢰적인 데이터 전송을 구현하지만 UDP는 연결상태를 유지하지 않으며 어떠한 파라미터도 기록하지 않는다.

- 작은 패킷 헤더 오버헤드

  TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP는 8바이트의 오버헤드를 가진다.

<br />
<br />

## UDP 세그먼트 구조

![image (1)](https://user-images.githubusercontent.com/103870198/215431964-e7fc512a-58ec-4a51-8d5e-3c6656e651a5.png)

<br />

### UDP 체크섬

오류 검출을 위한 것이다.

체크섬은 세그먼트가 출발지로부터 목적지로 이동했을 때 UDP 세그먼트 안에 비트에 대한 변경사항이 없는지 검사하는 것.

체크섬을 통해 오류 검사만 할 뿐 복구하는 일은 하지 않는다.

<br />
<br />

## TCP

신뢰적이고 연결지향형이다.

데이터 전송을 보장하는 파라미터들을 각자 설정하기 위한 사전 세그먼트들을 보내야 하는 `핸드셰이크` 과정을 먼저 해야 하기 때문에..

- 전이중 서비스(full-duplex service)

<br />

## TCP 연결 과정

TCP를 이용한 통신을 할 때 프로세스와 프로세스를 연결하기 위해 가장 먼저 수행되는 과정 중에

클라이언트와 서버가 3번의 세그먼트를 주고받는데 이걸

<b>`3-way handshake`</b> 라고 한다.

1. 클라이언트가 서버에게 요청 패킷을 보낸다.

   - 시퀀스 번호와 ACK 번호가 설정됨
   - Flag : SYN
   - 페이로드는 없음

2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보낸다.

   - 시퀀스와 ACK 번호 설정해서 보낸다.
   - Flag : SYN + ACK

3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다.

   - Flag : ACK

<br />

TCP 연결을 종료 할 때는 4번의 세그먼트를 주고받는데

이걸 <b>`4-way handshake`</b> 라고 한다.

1. 클라이언트에서 서버와의 연결 종료를 위해 서버에 FIN 패킷을 보내고 FIN_WAIT1 상태가 됩니다.

(반대로 서버에서 먼저 끊을 수 도 있습니다.)

2. 서버는 클라이언트로부터 FIN을 받고 응답 패킷 ACK을 보냅니다.

상태는 CLOSE_WAIT가 됩니다

3. 서버가 통신이 끝나면, 즉 연결을 종료할 준비가 되면 클라이언트에게 FIN패킷을 보내고 LAST_WAIT 상태가 됩니다

4. 클라이언트는 확인 패킷 ACK을 보내고 TIME_WAIT 상태가 됩니다.

## TCP 세그먼트 구조

![다운로드 (1)](https://user-images.githubusercontent.com/103870198/215436121-b2cbaa5b-ed7c-4384-ba4f-9035bd66d44b.png)

<br />

## 흐름 제어

- 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 방법

- receiver가 packet을 지나치게 많이 받지 않도록 조절하는 것

- receiver가 sender에게 현재 자신의 상태를 알린다.

### 해결방법

- Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법

- Sliding Window : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법

<br />

## 혼잡 제어

데이터가 몰릴 경우 자신에게 온 데이터를 모두 처리할 수 없게 된다.

이런 경우 호스트들은 다시 재전송을 하게 되고 결국 혼잡만 가중시켜 데이터 손실을 발생하게 되는데

이런 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이는 작업을 혼잡제어라고 한다.

- AIMD(Additive Increase / Multiplicative Decrease)

  처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
  패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
  공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.
  문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.

- Slow Start (느린 시작)

  AIMD 방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재했다.
  Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 2배로 된다.
  전송속도는 AIMD에 반해 지수 함수 꼴로 증가한다. 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.
  처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
  그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.

- Fast Retransmit (빠른 재전송)

  빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다.
  패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
  단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
  중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.

- Fast Recovery (빠른 회복)

  혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

<hr >

q1. TCP와 UDP를 설명해주세요

꼬리질문) 다중화와 역다중화
꼬리질문2) 3-way handshake 와 4-way handshake

q2. 흐름제어와 혼잡제어에 대해 설명해주세요
꼬리질문 ) 각각의 해결방법

q3. TCP가 신뢰성을 보장하는 방법

TCP는 자신이 보낸 데이터에 대해 상대방이 받았다는 응답을 받아야 통신이 정상적으로 이루어졌다고 판단함.

자신이 보낸 데이터에 대한 응답을 받지 못하면 패킷이 윳리되었다고 판단하고 패킷을 재전송한다.

이 과정을 TCP 재전송 이라고 한다.

다시 보내기 때문에 성능의 저하를 가져오지만 TCP 통신의 특성상 반드시 필요한 과정이다.

- 체크섬을 통해 데이터 오류를 탐지할수 있음
- 순서가 뒤바뀌어도 시퀀스 넘버를 통해 순서를 보장해줄 수 있음
- 응답을 보낼 수 없는 상황이라면 timeout 개념을 사용한다. (일정 timeout된 시점에 다시 전송)
