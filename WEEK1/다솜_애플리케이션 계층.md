# 애플리케이션 계층

# 애플리케이션 구조

애플리케이션 개발자에 의해 설계되고 애플리케이션이 다양한 종단 시스템에서 어떻게 조작되어야 하는지를 지시한다. 애플리케이션 구조에는 클라이언트-서버 구조와 P2P 구조가 있다.

## 클라이언트-서버 구조

### 서버

- 항상 켜져 있는 호스트
- 고정 IP 주소를 갖는다.
- 클라이언트의 요청을 받는다.
- 확장을 위해 많은 수의 서버가 갖춰진 데이터 센터를 사용한다.

### 클라이언트

- 가끔 혹은 항상 켜져 있는 호스트
- 동적 IP 주소를 갖는다.
- 서버에 요청한다.
- 클라이언트들끼리 서로 직접적으로 통신하지 않는다.

<br>

# 다른 호스트에 있는 프로세스 간 통신

다른 호스트에 있는 프로세스는 소켓으로 통신한다.

## 소켓

- 커널이 제공하는, 네트워크와 관련된 시스템 콜(인터페이스)이다.
- 소켓 위치: 애플리케이션 계층과 전송 계층의 사이
- 소켓 주소: 목적지의 IP 주소 + 포트 번호

<aside>
💡 IP 주소: 32비트로 구성되며, 호스트를 유일하게 식별한다.
포트 번호: 애플리케이션(수신 소켓)을 식별하기 위해 사용된다. 애플리케이션마다 고정된 포트 번호를 사용한다. Ex:) 웹 서버:  80

</aside>

<br>

# 애플리케이션이 이용 가능한 전송 계층의 서비스

애플리케이션이 이용 가능한 전송 계층의 서비스에는 TCP와 UDP가 있다.

## TCP 서비스

### 연결지향형 서비스

애플리케이션 계층 메시지를 전송하기 전에 클라이언트와 서버가 서로 전송 제어 정보를 교환하도록 한다. == 핸드셰이킹

### 신뢰적인 데이터 전송 서비스

모든 데이터를 오류 없이 올바른 순서로 전달하게 한다. 즉, 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림을 손실되거나 중복되지 않게 수신 소켓으로 전달한다.

전자메일, 원격 터미널 접속, 웹, 파일 전송, 스트리밍 멀티미디어, 인터넷 전화 등이 TCP 서비스를 이용한다.

## UDP 서비스

최소의 서비스 모델을 가진 간단한 전송 프로토콜이다. 비연결성, 비신뢰성 특성을 가진다. 인터넷 전화(스카이프) 등이 UDP 서비스를 이용한다.

보안 등의 서비스는 애플리케이션 계층에서 직접 구현한다.

<br>

# HTTP

HTTP(HyperText Transfer Protocol)는 웹의 애플리케이션 계층 프로토콜이다.

HyperText: 중간중간에 다른 자료를 참조하는 링크가 있는 텍스트

즉, HTTP는 링크가 있는 텍스트를 전송하는 프로토콜이다.

# Request와 Response

HTTP는 Request와 Response로 이루어진다. 클라이언트는 Request을 하고 서버는 Request에 맞는 Response을 한다.

### HTTP 헤더

- HTTP 전송에 필요한 모든 부가 정보

## 요청 메시지

| 시작 라인 | GET /search?q=HTTP&hl=ko HTTP/1.1 |
| --- | --- |
| 헤더 | Host: www.google.com |
| 공백 라인(CRLF) |  |
| 메시지 바디 | 요청 메시지도 메시지 바디를 가질 수 있다. |

### HTTP 메서드

- 서버가 수행해야 할 동작을 지정한다.
- GET, POST, PUT, DELETE 등

### 요청 대상

- 절대경로?쿼리

### HTTP 버전

- HTTP/1.1 등

### Host

- 요청한 호스트 정보 == 도메인 정보
- 필수적이다.
- 하나의 서버가 여러 도메인을 처리해야 하는 경우, 하나의 IP 주소에 여러 도메인이 적용되어 있는 경우 활용된다.

## 응답 메시지

| 시작 라인 | HTTP/1.1 200 OK |
| --- | --- |
| 헤더 | Content-Type: text/html;charset=UTF-8
Content-Length:3423 |
| 공백 라인(CRLF) |  |
| 메시지 바디 | <html>
</html> |

### HTTP 버전

- HTTP/1.1 등

### HTTP 상태 코드

- 요청의 성공/실패를 나타낸다.
- 200(성공), 400(클라이언트 요청 오류), 500(서버 내부 오류) 등

### HTTP 상태 문구

- 사람이 이해할 수 있도록 짧게 상태 코드를 표현한다.

# TCP 서비스 사용

HTTP는 전송 계층의 TCP 서비스를 사용한다. 이에 따른 HTTP의 특징은 다음과 같다.

- 클라이언트-서버 사이에 TCP Connection이 맺어져야 한다.
- HTTP의 메시지들은 순서가 바뀌거나 유실되지 않는다.
- 위의 두 가지 특징을 위해 HTTP는 UDP를 사용하는 것보다 더 많은 네트워크 리소스를 이용(비용🔼)한다.

# Stateless(비상태성)

Request에 대한 Response 이후에 서버는 클라이언트에 대한 어떠한 기억도 하지 않는다. → 단순하다.

# HTTP가 TCP를 사용하는 2가지 방식

사전에 맺어둔 TCP 연결을 사용할 것인지, 아니면 매번 새로운 연결을 생성할 것인지에 따라 다르다.

RTT(round trip time): 작은 패킷 하나가 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간

## 지속 연결

- 한 번 설정한 TCP 연결을 계속 사용한다. 즉, 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다.
- 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다. 즉, 한 번의 연결로 다수 파일을 요청/응답받을 수 있다.
- HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결이다. 즉, 같은 서버에 있는 여러 웹 페이지들을 연결하여 한 번의 요청과 응답으로 보낼 수 있다.

## 비지속 연결

- 매 요청마다 새로운 TCP 연결을 맺는다. 즉, 매번 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다. 이 말은 매번 TCP 버퍼가 새롭게 할당되어야 하고, TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 한다는 것이다. 이는 수많은 다른 클라이언트의 요청을 동시에 서비스하는 웹 서버에게 심각한 부담을 줄 수 있다.
- 각 객체는 2 RTT를 필요로 한다. TCP 연결 설정에 1 RTT, 객체를 요청하고 응답을 받는 데 1 RTT가 필요하다. 즉, 오버헤드가 크다.

<br>

# 쿠키

Stateless를 보완하기 위해 사용한다. 웹 브라우저에 쿠키 정보를 저장해두고 해당 도메인의 매 요청마다 HTTP 헤더의 Cookie에 쿠키를 실어 보낸다.

예를 들어, 웹 브라우저가 종료되기 전까지 로그인을 유지하기 위해 세션을 사용한다면, Cookie에 JSESSIONID가 실린다. 쿠키 만료 기간 전까지 로그인을 유지하기 위해 쿠키를 사용한다면, Spring Security의 경우 기본적으로 Cookie에 remember-me가 실린다.

<br>

# 웹 캐싱

원출처의 웹 서버를 대신한다. 자체 저장 디스크를 가지고 있어 **최근 호출된 객체의 사본을 저장 및 보존**한다. 일반적으로 ISP가 구입하고 설치한다.

## 클라이언트 요청 시 동작 과정

웹 캐시에 객체가 있으면 TCP 연결 후 바로 보내고, 없으면 원출처에서 받아서 웹 캐시에 복사한 뒤 보낸다. 자세한 과정은 아래와 같다.

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본이 자신에게 저장되어 있는지 확인한다. 만약 저장되어 있다면, 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.
    1. 만약 웹 캐시에 객체의 사본이 저장되어 있지 않다면, 웹 캐시는 원출처와 TCP 연결을 설정한다.
    2. 웹 캐시와 원출처 간의 TCP 연결을 설정한다.
    3. 웹 캐시는 원출처에게 객체에 대한 HTTP 요청을 보내고, 원출처는 웹 캐시에게 요청에 대한 응답을 보낸다.
    4. 웹 캐시가 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보낸다.

## 장점

- 캐시 히트(웹 캐시에 객체가 있는 경우)가 일어날 경우 요청이 외부로 나가고 응답이 내부로들어오지 않아도 된다. 히트율이 높을수록 좋다.
- 클라이언트의 요구에 대한 응답 시간이 줄어든다. (클라이언트 입장에서 좋다.)
- 기관 입장에서는 외부로 나가는 트래픽이 줄어 비용을 줄일 수 있다. (기관 입장에서 좋다.)
- 서버 부하가 줄어든다. (서버 입장에서 좋다.)

## 단점

- 복사본이 웹 캐시에 캐시된 이후에 원출처에 있는 객체가 갱신된 경우, 과거의 객체를 가져올 수 있다. 즉, **일관성 문제**가 발생할 수 있다.
- 보안에 취약하다.

## 조건부 GET: 웹 캐싱의 일관성 문제를 개선하는 방법

조건: HTTP 요청 시에 GET 메서드를 사용하고, 헤더에 If-Modified-Since를 포함한다.

조건에 따라 GET한다. 이 방법을 사용하면 항상 최신 객체를 응답받을 수 있어 일관성 문제를 일부 해결할 수 있다.

1. 웹 브라우저가 프록시 서버에 조건부 GET 요청을 보낸다.
    1. 프록시 서버에 해당 객체가 없다면, 프록시 서버는 원출처에게 GET 요청을 보낸다. 원출처에서는 프록시 서버에 객체와 Last-Modified 정보를 응답으로 보낸다. 프록시 서버는 원출처로부터 응답으로 받은 객체을 웹 브라우저에게 보내 주고, 프록시 서버에도 Last-Modified와 함께 저장한다.
    2. 프록시 서버에 해당 객체가 있다면, 프록시 서버는 원출처에게 요청으로 Last-Modified를 보내고 응답을 받는다.
        1. Last-Modified 이후 수정된 적이 없다면 원출처의 응답은 304 Not Modified이다. 이 경우 프록시 서버가 가지고 있는, 객체의 복사본을 웹 브라우저에게 응답으로 보내면 된다.
        2. Last-Modified 이후 수정된 적이 있다면 원출처는 응답으로 요청된 객체와 Last-Modified 정보를 보낸다. 프록시 서버는 원출처로부터 응답으로 받은 객체을 웹 브라우저에게 보내 주고, 프록시 서버에도 Last-Modified와 함께 저장한다.

# SMTP

Simple Mail Transfer Protocol로 번역하면 간이 우편 전송 프로토콜이다. 인터넷에서 이메일을 보내기 위해 이용된다. TCP 포트 번호 25번을 사용한다.

SMTP는 텍스트 기반의 프로토콜로서 요구/응답 메시지뿐 아니라 모든 문자가 7bit 아스키로 되어있어야 한다. 이 때문에 문자 표현에 8비트 이상의 코드를 사용하는 언어(Ex: 한글) 등은 마임 방식을 통해 7비트로 변환되어 전달된다.

# DNS

Domain Name Service. 휴대전화에 전화번호를 저장해두고, 사용자가 전화를 걸 때 번호가 아닌 이름을 가지고 전화를 거는 것과 비슷하다. 즉, **HOST 이름(도메인 이름)→IP 주소 매핑**을 하는 것이다. 도메인 이름은 사람들이 많이 사용하는 IP에 붙여준다.

| 도메인 이름 | IP 주소 |
| --- | --- |
| www.naver.com | 숫자 주소 |
| www.google.com | 숫자 주소 |

## 가장 간단한 구현 방법

어떤 서버 하나에 HOST 이름과 IP 주소를 매핑하는 데이터베이스를 두고, 모든 클라이언트가 HOST 이름으로 요청하고 해당 서버에서 IP 주소를 응답받는다.

### 문제점

- 도메인과 IP 주소가 셀 수 없이 많아(규모가 커서) 검색 시간이 너무 오래 걸린다.
- 서버에서 멀리 떨어져있는 클라이언트는 요청과 응답에 많은 시간이 소요된다.
- 서버 하나가 멈추면 모두가 DNS를 이용할 수 없게 된다.

### 해결 방법

- DNS 서버를 분산화한다.
- DNS 서버를 계층화한다.

무슨 일이든… 규모가 커지면 분산화·계층화하는 것이 좋다.

## 분산화 구조

![https://www.cloudflare.com/img/learning/dns/glossary/dns-root-server/dns-root-server.png](https://www.cloudflare.com/img/learning/dns/glossary/dns-root-server/dns-root-server.png)

DNS는 어떤 도메인이 그 하위의 도메인을 관리하는 구조로 이루어져 있다.

로컬 DNS 서버도 캐시를 사용한다. 내부 사용자가 요청하면, 도메인 이름을 로컬 DNS 서버에 먼저 검색하고, 로컬 DNS 서버에 없을 경우 외부에 검색한다. 이런 방식을 사용하면 로컬 서버에서 캐시 히트되는 경우가 많다. 즉, **DNS를 사용할 때 외부에 검색할 일이 적어진다.**

### 분산화 계층

- 루트 DNS 서버
- TLD 서버: 최상위 레벨 도메인 서버이다. org, com, net 등을 포함한다.
- 책임 DNS 서버: 실제 도메인의 IP 주소가 기록되는 서버이다.
    - Ex: www.naver.com

<br>

### 로컬 서버 캐시의 일관성 문제

참고: [TTL](https://thebook.io/007046/ch07/02/06/02/)

대응책으로 DNS의 TTL 필드가 있다. 도메인의 TTL(Time To Live) 값은 DNS에 질의해 응답받은 결과를 캐시에서 유지하는 시간을 뜻한다. TTL 필드는 시간을 설정하여 그 시간이 지나면 유효기간이 만료되게 만들어진다.

## DNS 레코드

DNS 레코드는 (Name, Value, Type, TTL) 필드로 이루어져 있다.

### Type 필드

Type A 레코드와 Type NS 레코드는 한 쌍으로 같이 존재한다. 책임 서버면 그 호스트 네임에 대한 Type A 레코드를 포함하고, 책임 서버가 아니면 호스트 네임을 포함하는 도메인에 대한 Type NS 레코드를 포함하는 식이다.

- “Type=A”: Name은 호스트 네임이고 Value는 호스트 네임에 대한 IP 주소이다.
    - Ex:) (www.naver.com, 223.130.200.104, A)
- “Type=NS”: Name은 도메인이고 Value는 도메인 내부의 호스트에 대한 IP 주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 네임이다.
    - NS는 Name Server의 약자
    - Ex:) (naver.com, shopping.naver.com, NS)
- “Type=CNAME”: Value는 별칭 호스트 네임 Name에 대한 정식 호스트 네임이다.
- “Type=MX”: Value는 별칭 호스트 네임 Name을 갖는 메일 서버의 정식 이름이다.

<br>

# 질문 목록

- HTTP 메서드의 멱등성이 무엇인가요?
- HTTP 메서드 중 PUT과 PATCH를 비교해 주세요.
- DNS가 무엇인가요? 언제 사용하나요?