# 네트워크 스터디



### Socket

우리가 개발하는 네트워크 애플리케이션은 end point에서 실행되는 프로세스이다. 종단간 통신방법은 각각의 client와 server가 소켓을 통해 메시지를 주고 받는다.

소켓은 어떠한 하드웨어 디바이스가 아니다 소켓은 OS단에서 제공 되는 추상화된 인터페이스이다. 소켓 자체가 커널의 일부분이라고 얘기할 수는 없다. 다만 커널이 제공하는 추상화이다. 소켓이 생성되면 그것은 특정한 포트와 ip어드레스에 bound 된다. 이것은 해당 ip어드레스와 포트로부터 오는 데이터를 받아들일 수 있다는 의미이다. 소켓은 TCP또는 UDP를 사용할지 결정될 수 있다. 보통 소켓이 생성된다는 의미는 소켓에 필요한 리소스를 할당받고 OS가 소켓 오브젝트는 초기화되어 kernel memory안에 저장되는 것을 의미한다.

우리가 애플리케이션에서 커널의 기능을 사용하려면 시스템 콜을 사용해서 커널에서 실행되는 함수로 변화시키듯이 소켓 I/O도 마찬가지이다. 소켓 I/O를 통해 시스템 콜을 생성해 내면 커널은 네트워크 디바이스와 커뮤니케이션을 통해 이를 처리하고 데이터를 전달한다. 



### UDP vs TCP

애플리케이션 계층에서는 사용할 트랜스포트 계층 프로토콜을 결정해야 한다. 어떤 프로토콜을 결정할지는 보통 애플리케이션의 성격에 따라 나뉘게 된다.

트랜스포트 계층에서 제공할 수 있는 서비스는 대략 4가지가 있다. 신뢰적 데이터전송, 처리율, 시간, 보안이다. UDP는 최소의 서비스를 가진 프로토콜이며  커넥션을 필요로 하지 않는다. 데이터 전송간 손실이나 데이터 순서도 재정렬해주지 않는다. 이는 데이터 손실이 생겨도 애플리케이션 품질의 큰 변화가 없고 제대로 작동하는 애플리케이션에서 주로 쓰인다. 

무조건 TCP가 제공하는 서비스가 많으니 TCP를 쓰는게 좋냐고 얘기할 수 있지만 TCP 프로토콜이 가진 overhead가 존재하기 때문에 처리속도 측면에서는 UDP가 훨씬 유리하다고 볼 수 있다. 또한 지연율이 굉장히 낮으며 멀티캐스팅이 가능하다. TCP는 1:1로만 커넥션을 맺고 데이터를 전송하지만 UDP는 single udp packet이 여러개의 수신자에게 한번에 전송될 수 있다. 또한 같은 네트워크 상에 있는 모든 디바이스에게 브로드캐스팅도 가능하다. 



### Cookie vs Session

쿠키는 유저 컴퓨터에 저장되는 작은 텍스트 파일이다. 쿠키의 맥시멈 사이즈는 4KB이다. 유저가 웹사이트를 방문했을때 웹사이트측에서 유저에게 보내는 데이터이다. 쿠키는 오직 발행된 도메인에서만 읽을 수 있다. 보통 광고 업계에서는 유저를 타겟팅하기 위해서 쿠키싱크를 통해서 타 도메인에서 발행된 도메인을 읽을 수 있게 하는 기술이 존재한다. 쿠키의 지속시간은 서버에서 정할 수 있으며 쿠키의 성격에 따라서 sesison이 만료됨에 따라서 (브라우저 종료) 사라지는 쿠키와 일정 기간동안 계속 저장돼있는 쿠키가 있다. 

세션은 서버에 저장된다. 세션은 유니크 id를 할당받고 저장된 값을 읽어오는데 사용된다. 세션이 생성될때 세션의 유니크 아이디는 쿠키에 저장되어 모든 서버 요청에 세션의 유니크 id를 가지고 가게 된다. 만약 클라이언트의 브라우저가 쿠키를 지원하지 않는다면 유니크 세션 id는 URL에 나타나게 된다. 세션은 쿠키에 비해서 더 많은 양의 데이터를 저장할 수 있다.

세션 값은 브라우저가 닫힐때 자동적으로 삭제된다. 만약 해당 값을 계속 저장해두고 싶다면 디비에 저장해두면 된다. 세션 로그인 방식은 다음과 같다. 우리가 로그인을 하면 서버는 세션을 생성하고 쿠키에 세션ID를 태워서 보내준다. 그래야 클라이언트에서 어떠한 action이 발생했을때 서버는 그 액션이 누구의 것인지 확인할 수 있다. 이렇게 해야 하는 이유는 http가 stateless이기 떄문에 모든 요청에 내가 누구임을 확인시켜줄 요소가 필요한 것이다. 세션은 보통 타임 리밋이 있다. 그리고 세션은 보통 서버의 메모리나 파일시스템에 저장된다. 

요즘은 서버들이 보통 여러대가 존재하고 로드벨런서가 앞단에 존재한다. 그러면 이런 경우 세션은 어떻게 관리되어야 하는가? 이럴 경우 세션은 서버에 종속되어 있으므로 로드벨런서는 요청이 처음 갔던 서버에게 계속 보내줘야하는 부담이 생긴다. 이는 로드밸런서에 부하를 주게 된다. 또 다른 방법으로는 central한 디비를 하나 생성하여 세션 정보를 해당 디비에서 관리하는 것이다. 이런 경우에는 로드밸런서는 요청을 아무 서버에나 보내도 되기 때문에 로드밸런서에서 받는 부하를 줄일 수 있다. 대신 매 요청마다 DB I/O가 생길 수 있다는 단점이 있다. 또 다른 방법으로는 클러스터링된 서버들이 모두 같은 세션을 공유하게 하는 것이다. NFS와 같은 공용스토리지를 사용한다면 해당방법을 실현할 수 있다. 사실 세션의 한계는 분명히 존재하는 것처럼 보인다. session id 와 매칭되는 정보를 서버에서 저장해야된다라는 session과 서버의 종속성이 생기기 때문이다. 이를 해결하기 위해선 그냥 클라이언트에서 인증 관련 데이터를 같이 보내오면 될 것이다.