# 애플리케이션 계층

_애플리케이션 계층_ 은 네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳.

아래와 같은 프로토콜을 포함한다.

- HTTP(웹 문서 요청과 전송을 위해 제공)
- SMTP(전자메일 전송을 제공)
- FTP(두 종단 시스템간의 파일 전송 제공)

애플리케이션 계층 프로토콜은 여러 종단 시스템에 분산되어 있어서, 서로 정보 패킷을 교환하는데 이 프로토콜들을 사용한다.

애플리케이션 계층에서의 이 정보 패킷을 <b>메시지(message)</b> 라고 부른다.

클라이언트-서버 구조에서 항상 동작하고 있는 호스트를 서버라고 한다.

서버는 고정IP 이고 하나의 서버 호스트가 자신의 클라이언트로부터 오는 모든 요청을 다 처리할 수 없기 때문에 기업들은 대규모 데이터센터를 구축한다.

P2P(peer to peer)

p2p는 항상 켜져있는 서버에 최소로 의존하거나 전혀 의존하지 않는다.

피어(peer)라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신한다.

p2p 구조의 특징은 자가 확장성(self-scalability)

<br />

## 프로세스간 통신

실제 통신하는 것은 프로그램이 아니라 프로세스다.

2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메시지 교환으로 서로 통신한다.

> 두 프로세스 간의 통신 세션에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스를 클라이언트라 하고, 세션을 시작하기 위해 접속을 기다리는 프로세스를 서버라고 한다.

<br />

## 소켓(socket)

프로세스와 프로세스간의 통신을 위한 API

애플리케이션 프로세스와 트랜스포트 프로토콜 간의 인터페이스

트랜스포트 레이어는 TCP/UDP 프로토콜로 구현됨

TCP 소켓과 UDP 소켓이 있다.

<br />

## 프로세스 주소 배정

프로세스가 다른 프로세스에게 패킷을 보내려면 보낼 주소를 알아야 한다.

1. 호스트의 주소 (IP)
2. 호스트 내의 수신 프로세스를 명시하는 식별자 (port)

<br />

## 애플리케이션이 사용할 수 있는 트랜스포트 레이어 프로토콜

신뢰적 데이터 전송, 처리율, 시간, 보안 네 가지 차원으로 분류

- 신뢰적 데이터 전송(reliable data transfer)
  - 애플리케이션이 보낸 데이터가 올바르게 전송됨을 보장
  - 트랜스포트 계층에서 신뢰적 데이터 전송을 제공하지 않을 때 어느정도 데이터 손실 발생 가능
- 처리율
  - 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
  - 특정 처리율 요구사항을 갖고 있는 애플리케이션은 _대역폭 민감 애플리케이션(bandwidth-sensitive application)_ 이라 한다.
- 시간
  - 트랜스포트 계층은 시간 보장(time guarantee)를 제공할 수 있다.
  - 송신자가 보내는 데이터가 수신자에게 얼마만에 도착하는지에 대한 제한
  - 인터넷 전화, 화상 회의, 실시간 게임 등은 엄격한 시간 제한 조건이 필요
- 보안
  - 트랜스포트 계층은 애플리케이션에 하나 이상의 보안 서비스를 제공할 수 있다.
  - 송,수신 데이터 암호화 및 복호화

<br />

## 인터넷 전송 프로토콜이 제공하는 서비스

인터넷은 애플리케이션에게 2개의 전송 프로토콜을 제공 한다.

<br />

### <b>TCP(Transmission Control Protocol)</b>

TCP는 연결지향형 서비스와 신뢰적 데이터 전송 서비스를 포함한다.

또한 TCP는 혼잡 제어 방식, 즉 통신하는 프로세스의 직접 이득보다는 인터넷의 전체 성능 향상을 위한 서비스를 포함한다.

- 연결지향형 서비스
  - 애플리케이션 계층 메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환하게 한다.
  - 이 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 곧 도달할 테니 준비하라고 알려주는 역할을 한다.
  - 핸드셰이킹 단계를 지나면, TCP 연결이 두 프로세스의 소켓 사이에 존재한다고 말한다.
  - 이 연결은 두 프로세스가 서로에게 동시에 메시지를 보낼 수 있기에 전이중(full-duplex) 연결이라고 한다.
  - 애플리케이션이 메시지 전송을 마치면 연결을 끊어야 한다.
- 신뢰적인 데이터 전송 서비스
  - 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP에 의존한다.
  - TCP는 애플리케이션의 한쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림이 손실되거나 중복되지 않게 소켓으로 전달한다.

<br />

### <b>UDP(User Datagram Protocol)</b>

UDP는 최소의 서비스 모델을 가진 간단한 전송 프로토콜이다.

UDP는 비연결형이므로 두 프로세스가 통신을 하기 전에 핸드셰이킹을 하지 않는다.

UDP는 비신뢰적인 데이터 전송 서비스를 제공한다. 즉, 하나의 프로세스가 UDP 소켓으로 메시지를 보내면,

UDP는 그 메시지가 수신 소켓에 도착하는 것을 보장하지 않는다. 게다가 수신 소켓에 도착하는 메시지들의 순서가 뒤바뀔 수도 있다.

UDP는 혼잡 제어 방식을 포함하지 않는다.

<br />

## 애플리케이션 계층 프로토콜

애플리케이션 계층 프로토콜은 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의한다.

<b>_HTTP(HyperText Transfer Protocol)_</b> 도 애플리케이션 계층 프로토콜 중에 하나이다.

- 교환 메시지 타입(요청 메시지와 응답 메시지)
- 여러 메시지 타입의 문법(메시지 내부의 필드와 필드 간의 구별법)
- 필드의 의미, 즉 필드에 있는 정보의 의미
- 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙

<br />

## HTTP(HyperText Transfer Protocol)

HTTP는 TCP를 전송 프로토콜로 한다.

HTTP는 데이터의 손실 또는 TCP가 어떻게 데이터를 복구하고 올바른 순서로 배열하는지 걱정할 필요가 없다.

TCP와 프로토콜 스택의 하위 계층들이 하는 일이기 때문

HTTP는 클라이언트에 대한 정보를 유지하지 않으므로, HTTP를 <b>_비상태 프로토콜(stateless protocol)_</b> 이라고 한다.

<br />

### 비지속 연결과 지속 연결

클라이언트-서버 상호작용이 TCP 상에서 발생할 때 각 요구/응답 쌍이 분리된 TCP 연결을 통해 보내져야 하는가?

혹은 모든 요구와 해당하는 응답들이 같은 TCP 연결상으로 보내져야 하는가?

전자 방식의 경우 애플리케이션은 <b>_비지속 연결(non-persistent connection)_</b> 이라 하고,

후자의 경우 <b>_지속 연결(persistent connection)_</b> 이라 한다.

HTTP는 디폴트로 지속 연결을 사용하지만, 비지속연결을 사용하도록 설정할 수 있다.

<br />

### <b>비지속 연결 HTTP</b>

```
  http://www.someschool.edu/someDepartment/home.index
```

1. HTTP 클라이언트는 HTTP의 기본 포트 번호 80을 통해 www.someschool.edu 서버로 TCP 연결을 시도한다. TCP 연결과 관련하여 클라이언트와 서버에 각각 소켓이 있게 된다.
2. HTTP 클라이언트는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다. 이 요청 메시지는 /someDepartment/home.index 경로 이름을 포함한다.
3. HTTP 서버는 1단계에서 설정된 연결 소켓을 통하여 요청 메시지를 받는다. 저장장치로부터 /someDepartment/home.index 객체를 추출한다. HTTP 응답 메시지에 그 객체를 캡슐화한다. 그리고 응답 메시지를 소켓을 통해 클라이언트로 보낸다.
4. HTTP 서버는 TCP에게 연결을 끊으라고 한다.(그러나 실제로 TCP 클라이언트가 응답 메시지를 올바로 받을 때까지 연결을 끊지 않는다.)
5. HTTP 클라이언트가 응답 메시지를 받으면, TCP 연결이 중단된다. 메시지는 캡슐화된 객체가 HTML 파일인 것을 나타낸다. 클라이언트는 응답 메시지로부터 파일을 추출하고 HTML 파일을 조사하고 10개의 JPEG 객체에 대한 참조를 찾는다.
6. 그 이후에 참조되는 각 JPEG 객체에 대하여 처음 네 단계를 반복한다.

앞 단계에서 서버는 객체를 보낸 후에 각 TCP 연결이 끊어지므로 비지속 연결을 사용하고 있습니다(연결이 다른 객체를 위해 유지되지 않음). 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송합니다. 그래서 이 예에서는 사용자가 웹 페이지를 요청할 때 11개의 TCP 연결이 만들어집니다.

클라이언트가 기본 HTML 파일을 요청하고 그 파일이 클라이언트로 수신될 때까지의 시간을 측정해 봅시다. 이를 위해서 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간이 RTT(round trip time)을 정의합니다.

<br />

> <b>RTT(round-trip time)</b> 패킷이 클라이언트로부터 서버까지 가고 다시 클라이언트로 돌아오는데 걸리는 시간.<br />RTT는 패킷 전파 지연, 중간 라우터와 스위치에서의 패킷 큐잉 지연, 패킷 처리 지연 등을 포함한다.

<br />

### <b>지속 연결 HTTP</b>

<br />

<b>비지속 연결은 몇 가지 단점이 있습니다.</b>

첫째, 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 합니다.

TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 합니다.
이는 수많은 다른 클라이언트의 요청을 동시에 서비스하는 웹 서버에게 심각한 부담을 줄 수 있습니다.
둘째, 앞서 언급한 대로 각 객체는 2 RTT를 필요로 했습니다.

TCP 연결 설정에 1 RTT
객체를 요청하고 받는데 1 RTT
HTTP1.1 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지합니다.

- 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내집니다.
- 특히, 전체 웹 페이지(앞 예에서 기본 HTML 파일과 10개 이미지)를 하나의 지속 TCP 연결을 통해 보낼 수 있습니다.
- 또한 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있습니다.
- 이들 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있습니다.(파이프라이닝)

일반적으로 HTTP 서버는 일정 기간(타임아웃 기간) 사용되지 않으면 연결을 닫습니다. 서버가 연속된 요구를 수신할 때, 서버는 객체를 연속해서 보냅니다. HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결을 사용합니다.

최근에, HTTP/2와 같은 연결상에서 다중 요청(request)과 응답(reply)이 가능하고 이 연결 내에서 HTTP 메시지 요청과 응답의 우선순위 기법이 가능하도록 HTTP1.1을 기반으로 제안되었습니다.

<br />

## HTTP 요청 메시지

```json
{
  GET /somdir/page.html HTTP/1.1 // request Line
  Host : www.someschool.edu // 아래로는 다 header line
  Connection: close
  User-agent: Mozilla/5.0
  Accept-language: fr
}
```

- 요청 라인(request line) : 3개의 필드를 갖는다. 방식(method) 필드, URL 필드, HTTP 버전 필드
- Host : 객체가 존재하는 호스트를 명시
- Connection : close 헤더 라인을 포함함으로써, 브라우저는 서버에게 지속 연결을 원하지 않는다는 것을 명시
- User-agent : 사용자 에이전트, 즉 서버에게 요청하는 브라우저 타입을 명시
- Accept-language : 사용자가 객체의 프랑스어 버전을 원하고 있음을 명시, 존재하지 않으면 서버는 기본 설정 언어를 보낸다.

<br />

### HTTP 응답 메시지

```json
{
  HTTP/1.1 200 OK // status line
  Connection: close // 아래로는 다 헤더 라인
  Date: Tue, 18 Aug 2015 15:44:04 GMT
  Server: Apache/2.2.3 (CentOS)
  Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
  Content-Length: 6821
  Content-Type: text/html
  {
    some data... // 개체 몸체
  }
}
```

- 상태 라인(status line) : 프로토콜 버전 필드, 상태 코드, 해당 상태 메시지를 갖는다.
- Connection : close를 포함함으로써 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는데 사용
- Date : HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간
- Server : 메시지가 아파치 웹 서버에 의해 만들어졌음을 의미 -> HTTP Request의 User-agent 와 비슷
- Last-Modified : 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 의미, 이 헤더는 캐싱에 매우 중요하다.
- Content-Length : 송신되는 객체의 바이트 수
- Content-Type : 개체 몸체 내부의 객체가 HTML 텍스트인 것을 나타냄. 객체 타입은 확장자가 아니라 공싱적으로 Content-Type 헤더로 나타낸다.

<br />

### 일반적인 HTTP status code, message

- 200 OK : 요청이 성공했고, 정보가 응답으로 보내졌다.
- 301 Moved Permanently : 요청 객체가 영원히 이동되었다. 새로운 URL은 응답 메시지의 Location 헤더에 나와 있다.
- 400 Bad Request : 서버가 요청을 이해할 수 없다는 일반 오류 코드
- 401 Unauthorized : 유효한 인증 자격이 없기 떄문에 요청이 적용되지 않음
- 403 Forbidden : 서버에 정상적으로 요청이 전달되었지만, 권한 때문에 거절, 401과 비슷하지만 틀린 비밀번호로 로그인하는 것처럼 지속적으로 접속을 거절함.
- 405 Method Not Allowed : 메소드 매칭이 되지 않아 생기는 오류
- 404 Not Found : 요청 문서가 서버에 존재하지 않는다.
- 500 Internal Server Error : 서버가 요청을 처리하는 과정에서 예기치 못한 상황으로 에러 발생
- 503 Service Unavailable : 서버가 요청을 처리할 준비가 되지 않은 것을 의미
- 505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.

<br />

> ### q1. 301 status code의 용도, 301과 302의 차이는 ?

<br />

## HTTP 요청 메소드

- GET : 특정한 리소스를 가져오도록 요청, GET은 데이터를 가져올 때만 사용해야 한다. GET 요청에 본문이나 페이로드를 담으면 안된다.

- POST : 서버로 데이터를 전송한다. 요청 본문의 유형은 Content-Type 헤더로 나타낸다.

- PUT : 요청 페이로드를 사용해 새로운 리소스를 생성하거나, 대상 리소스를 나타내는 데이터를 대체한다.

- PATCH : 리소스의 부분적인 수정을 할 때에 사용한다.

- DELETE : 지정한 리소스를 삭제한다.

<br />

## 쿠키(Cookie)

HTTP 서버는 상태를 유지하지 않는 비상태 서버이다.

그러나 서버가 사용자 접속을 제한하거나 사용자에 따라 컨텐츠를 제공하기 원하므로 웹 사이트가 사용자를 확인하는 작업이 필요할 경우가 생긴다.

이 목적으로 HTTP는 쿠키를 사용한다.

HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다.

쿠키의 네 가지 요소

- HTTP 응답 메시지 쿠키 헤더 라인
- HTTP 요청 미시지 쿠키 헤더 라인
- 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
- 웹 사이트의 백엔드 데이터베이스

<br />

쿠키의 세 가지 목적

- 세션 관리(Session management) : 로그인, 장바구니 등의 정보 관리
- 개인화(Personalization) : 사용자 선호, 다크모드 등의 세팅
- 트래킹(Tracking) : 사용자 행동을 기록하고 분석하는 용도

<br />

### Set-Cookie 그리고 Cookie 헤더

```json
  // Set-Cookie
  Set-Cookie: <cookie-name>=<cookie-value>

  // Cookie 헤더
  {
    HTTP/1.0 200 OK
    Content-Type: text/html
    Set-Cookie: my_cookie=yoo
  }
```

> ### q2. 쿠키의 단점을 말해주시고 대체제를 말씀해주세요

<br />

<br />

## 웹 캐싱

웹 캐시(Web cache) 또는 프록시 서버(proxy server) 는 원본 웹서버(origin) 대신 HTTP 요청을 충족시키는 네트워크 개체다.

웹 캐시는 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다.

웹 캐싱의 장점

1. 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다.
2. 클라이언트가 요청한 객체를 캐시가 가지고 있다면, 캐시는 그 객체를 클라이언트로 매우 빠르게 전달할 수 있다.
3. 웹 캐시는 한 기관에서 인터넷으로 접속하는 링크 상의 웹 트래픽을 대폭으로 줄일 수 있다.

<br />

> ### q3. 캐시는 서버이면서 클라이언트라는 표현이 나오는데 어떤 이유 때문일까요?

<br />

<br />

## 조건부 GET

캐시는 응답시간을 줄일 수 있지만, 캐시에서 응답 받은 데이터가 최신이 아닐수도 있다는 문제점이 있다.

HTTP는 이러한 문제를 해결하는 방법으로 모든 객체들이 최신인걸 확인하면서 캐싱하는 방식을 갖고 있는데

이러한 방식을 <b>_조건부 GET(conditional GET)_</b> 이라고 한다.

HTTP 요청 메시지가 아래를 만족한다면 조건부 GET 메시지이다.

- GET 방식을 사용한다.
- [If-Modified-Since](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/If-Modified-Since) 헤더 라인을 포함한다.

origin의 Last-Modified 날짜와 If-Modified-Since 헤더에 주어진 날짜를 비교 한다.

<br />

## HTTP/2

HTTP/1.1 의 문제점을 보완하기 위해 나온 프로토콜

HTTP/2의 주요 목표는

- TCP 연결상에서 멀티플렉싱 요청/응답
- 요청 우선순위화
- 서버 푸쉬
- HTTP 헤더 압축

HTTP/2 는 클라이언트와 서버 간의 데이터 포맷 방법과 전송 방법을 변경했다.

<br />

## HTTP의 HOL Blocking과 TCP에서의 HOL Blocking

<br />

### <b>HTTP/1.1과 HTTP/2 에서의 HOL Blocking</b>

<br />

HTTP/1.1 의 요청-응답 쌍은 항상 순서를 유지하고 동기적으로 수행되어야 한다.

```
|---a.png---|
            |---b.png---|
                        |---c.png---|
```

그런데 a.png 요청에서 병목이 발생하면

```
|------------a.png------------|
                              |-b.png-|
                                      |---c.png---|

```

가 되므로 전체적으로 느려지게 된다.

이게 바로 HTTP/1.1의 HOL Blocking 이다.

HTTP/2의 경우

요청은 하나의 연결에서 병렬적으로 보내질 수 있다.

```
|------------a.png------------|
|-b.png-|
|---c.png---|
```

또한 HTTP/2는 중요한 자원의 우선순위를 부여하는 기능이 있기 때문에 세세한 제어가 가능하다.

### <b>TCP 에서의 HOL Blocking</b>

TCP는 패킷을 전송할 때, 전달을 보장해야 하기 때문에 패킷이 손실되면 재전송을 하게 된다.

재전송이 발생하게 되면 패킷의 순서가 역전되지 않도록 후속 패킷이 대기하게 된다.

이것이 TCP 에서의 HOL Blocking 이다.

```
|----packet1----|xxx lost xxx|----packet1----|
                                             |-packet2-|
                                                       |--packet3--|
```

<br />

## SMTP(Simple Mail Transfer Protocol)

이메일을 전송할 때 사용하는 프로토콜

<br />

## DNS(Domain Name System)

DNS는 인터넷에 연결된 리소스에 대한 계층적이고 분산된 이름 지정 시스템이다.

DNS의 주요 기능은 사람에게 친숙한 도메인 이름(www.google.com) 을 숫자 IP 주소로 변환하는 것이다.

모든 DNS 질의와 응답 메시지는 53 port를 사용한다.

DNS 를 통한 웹사이트 접속 과정

1. 클라이언트(사용자)가 브라우저를 통해 www.google.com 에 접속
2. 브라우저는 URL 로 부터 hostname을 추출하고 DNS 서버에 질의
3. DNS 서버로 부터 hostname에 해당하는 IP 주소 응답 받음
4. 클라이언트(사용자)의 브라우저는 해당 IP 주소의 80포트로 TCP 연결 초기화

DNS를 통한 질의 과정은 계층 구조로 되어있는 DNS 서버들에게 재귀적 호출을 하면서 찾게 되는데

이 과정을 줄이기 위해 DNS 캐싱을 사용한다.

<br />

> ### q4. DNS 서버에서 해당 IP주소를 찾지 못할 경우 어떻게 될까요?

> ### q5. DNS_PROBE_FINISHED_NXDOMAIN 와 HTTP status 404의 차이점은?

<br />

<br />

## 콘텐츠 분배 네트워크(Contents Distribution Network, CDN)

전 세계의 수억명의 사용자들에게 끈김 없이 안정적으로 콘텐츠를 제공하는 일은 매우 어려운 문제다.

CDN은 다수의 지점에 분산된 서버들을 운영하며, 비디오 및 다른 형태의 웹 콘텐츠 데이터의 복사본을 분산 서버에 저장한다.

CDN은 일반적으로 서버의 위치에 대해 다음 두가지 철학 중 하나를 채용한다.

| 종류       | 특징                                                                                                   | 장점                                                                    | 단점                                                      |
| ---------- | ------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------- | --------------------------------------------------------- |
| Enter Deep | 서버 클러스터를 세계 곳곳의 접속 네트워크에 구축함으로써 ISP의 접속 네트워크로 깊숙이 들어가는 것이다. | 서버를 최대한 사용자 가까이 위치시켜, 지연 시간 및 처리율을 향상시킨다. | 고도로 분산된 설계로 유지 관리 비용이 커진다.             |
| Bring Home | 보다 적은 수의 핵심 지점에 큰 규모의 클러스터를 구축하여 ISP를 Home 으로 가져오는 개념                 | Enter Deep 에 비해 유지 관리 비용이 줄어든다.                           | 사용자가 느끼는 지연 시간과 처리율은 상대적으로 나빠진다. |
