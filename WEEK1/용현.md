# Application Layer
---

# Q&A
- 지속연결 와 비지속연결 비교
- 웹 브라우저가 호스트의 IP 주소를 얻는 과정 설명
- CDN 장점과 동작
---

# 네트워크 어플리케이션 원리

## 네트워크 어플리케이션 구조

**클라이언트-서버 구조**
- 클라이언트끼리 서로 직접적으로 통신하지 않고 서버에게 요청하는 구조
  - 웹 어플리케이션에서는 2개의 브라우저가 직접적으로 통신하지 않는다
- 클라이언트는 서버 주소로 패킷을 보내서 언제든지 서버에 연결할 수 있다.
- 서버는 클라이언트의 요청을 처리하기 위해서 고정 IP를 가져야 하고, 항상 동작해야 한다.
- 클라이언트-서버 구조로 이루어진 구조로는 웹,파일 전송,원격 로그인,전자메일들이 있다.

**P2P 구조**
- 항상 켜져 있는 인프라스트럭쳐 서버에 최소로 의존하거나 전혀 의존하지 않는다.
- 어플리케이션은 피어(peer)라는 간헐적으로 연결된 호스트쌍이 서로 직접 통신하는 구조이다.
- 피어는 서비스 제공자 소유하지 않고, 사용자들이 제어하는 컴퓨터이다.
- 특정 서버를 통하지 않고 피어가 통신하므로 Peer to Peer 구조 라고한다
- P2P 구조는 서버에 부하를 줄이기에 비용 효율적이다.
- 자가 확장성을 가진다. 
  - 예를 들어 파일 공유 어플리케이션에서 각 피어들은 파일을 다른 피어들에게
  - 분배함으로써 그 시스템에 서비스 능력을 추가한다.
- 고도의 분산 구조 특성으로 인해 보안,성능,신뢰성 면에서 문제점이 있다.


##  프로세스 간 통신
- 2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통해 **메시지 교환을 하며** 통신을 한다.
  - 송신 프로세스는 메시지를 만들어서 네트워크로 보내고
  - 수신 프로세스는 메시지를 받고 역으로 메시지를 보냄으로써 응답한다.
- 프로세스와 컴퓨터 네트워크 사이의 프로세스는 소켓을 통해 통신한다.
  - 소켓은 운영체제에서 제공해주는 호스트 어플리케이션 계층과 트랜스포트 계층 간의 인터페이스이다
- 프로세스 주소 배정
  - IP 주소(32bit)로 호스트를 식별하고
  - Port 번호로 프로세스를 식별한다
  - 즉, 송신 프로세스는 수신 프로세스의 IP 주소 + Port 번호를 수신 프로세스에 송신이 가능하다.


##  인터넷 계층 프로토콜

네트워크 프로세스는 소켓으로 메시지를 보냄으로써 통신한다. 
- 어떻게 메시지를 보낼까
- 메시지 구성은 어떻게 될까
- 메시지의 여러 필드는 의미하는 것이 뭘까
- 프로세스는 메시지를 언제 보내는가
사용하는 어플리케이션 프로토콜에 따라 위 네가지 사항은 달라진다.

- 어플리케이션 계층 프로토콜은 네트워크 어플리케이션의 한 요소이다.
- 어플리케이션 계층 프로토콜은 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 다음과 같이 정의한다
  1. 교환 메시지 타입(ex: 요청 메시지,응답 메시지)
  2. 여러 메시지 타입의 문법(메시지 내부의 필드와 필드 간의 구별 방법)
  3. 필드의 의미(즉, 필드에 있는 정보의 의미)
  4. 언제,어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙.
- 이러한 규칙을 따라 프로토콜이 결정된다.
---

#   웹과 HTTP
- 웹 어플리케이션은 HTML,웹 브라우저,웹 서버,어플리케이션 계층 프로토콜을 포함하는 여러 구성요소들로 구성된다.
- HTTP(HyperText Transfer Protocol)은 웹 어플리케이션 계층 프로토콜이다.
  
  각기 다른 종단 시스템에서 수행되는 클라이언트, 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다

- HTTP는 웹 클라이언트가 웹 서버에게 어떤 데이터를 요청하는지에 따라 서버가 클라이언트로 응답하는지를 정의한다.
- HTTP는 TCP 전송 프로토콜을 사용한다(TCP는 데이터 손실, 데이터 응답 순서를 보장해준다.)
  - HTTP 클라이언트는 서버에 TCP 연결을 시작한다
  - 연결이 이루어지면, 클라이언트와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다.
  - 클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고, 소켓 인터페이스로부터 HTTP 응답을 받는다.
  - 서버는 그 반대다.
- HTTP 서버는 클라이언트에 대한 정보(상태)를 보존하지 않으므로 , HTTP는 비상태 프로토콜이다.
  - 장점 : 서버 확장성 높음(스케일 아웃)
  - 단점: 클라이언트가 추가 데이터 전송해야 함

##  비지속 연결과 지속 연결
- 비지속연결: TCP 연결을 끊지 않고, 같은 TCP 연결 상으로 요청,응답이 보내진다.
- 지속연결: 요청,응답마다 TCP 연결을 맺고 끊는다

**HTTP는 디폴트 모드로 지속 연결을 사용하지만 HTTP 클라이언트와 서버는 비지속 연결을 사용하도록 설정할 수 있다.**


### 비지속 연결

- 응답 시간 = 2RTT + 파일 수신(파일 전송 시간)
  - 1 RTT: TCP 연결 초기화 시간
  - 2 RTT: 파일 요청하고 응답받는데 걸리는 시간
  - 파일 수신(파일 전송) 시간: 서버가 파일을 전송하는데 걸리는 시간

- 단점
  - 매 요청마다 TCP 연결을 해야한다
  - TCP 버퍼가 할당되어야 하고, TCP 변수들이 클라이언트와 서버 양쪽을 유지되어야 한다.
  - 수많은 클라이언트들의 요청을 동시에 서비스하는 웹 서버에 부담이 될 수 있다.

> RTT(round-trip time)
>
> 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는데 걸리는 시간
  
### 지속 연결

- 응답시간: 비지속연결은 매요청마다 2RTT가 고정으로 발생하는 반면에 2RTT가 1RTT로 줄어든다.
- TCP 연결을 그대로 유지한다
- 클라이언트와 서버 간의 이휴 요청과 응답은 같은 연결을 을 통해 보내진다.


### 요청 메시지 포맷

- 요청 라인: HTTP 요청 메시지의 첫줄
  - `방식 sp url sp 버전 cr lf`
- 헤더라인: 요청 라인 이후의 줄들은 헤더 라인
  - `헤더 필드이름 sp 값 cr lf`
- 공백 라인
- 개체 몸체


### 응답 메시지 포맷

- 상태 라인: HTTP 요청 메시지의 첫줄
  - `버전 sp 상태코드 sp 문장 cr lf`
- 헤더라인: 요청 라인 이후의 줄들은 헤더 라인
  - `헤더 필드이름 sp 값 cr lf`
- 공백 라인
- 개체 몸체

### 쿠키
- HTTP 서버는 stateless 하게 동작한다
- 쿠키를 사용하여 사용자에 대한 식별할 수 있다.

쿠키
- HTTP 응답 메시지 쿠키 헤더라인
  - `Set-Cookie: value`
- HTTP 응답 메시지 쿠키 헤더라인
  - `Cookie: value`
- 사용자 브라우저에서 쿠키 관리
- 백엔드에서 쿠키 저장

---

#   DNS(Domain Name System)
- 호스트 이름을 IP 주소로 변환해주는 디렉토리 서비스

  
1. 사용자 컴퓨터는 DNS 어플리케이션의 클라이언트를 수행한다.
2. 브라우저는 URL에서 호스트 이름을 추출하고 그 호스트 이름을 DNS 클라이언트에 넘긴다
3. DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하여 질의한다
4. DNS 클라이언트는 호스트 이름에 대한 IP 주소를 응답하고
5. 브라우저가 DNS로부터 IP 주소를 받으면, 브라우저는 해당 IP 주소 + 포트 번호로 HTTP 서버에 TCP 연결을 요청한다.


- 분산 계층 데이터 베이스
  - 트리구조를 가진다.
  - DNS 캐싱을 사용하여 지연 성능 향상과 네트워크의 DNS 메시지 수를 줄일 수 있다.
  - 확장성을 위해 DNS는 많은 서버를 전 세계에 분산시킨다.
  - DNS 서버는 다음과 같은 분산 계층을 가진다
    - 루트 dns 서버 > TLD 도메인 네임 dns 서버 > 책임 서버

- 루트 서버:
  - 1000개 이상의 루트 서버 인스턴스가 세계에 흩어져있음
  - TLD 서버의 IP 주소들을 제공한다
- TLD 서버:
  - com,org, 같은 상위 레벨 도메인과 kr,uk,fr 같은 모든 국가의 상위 레벨 도메인에 대한 서버가 존재한다.
- 책임 서버:
  - 인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 이름을 IP 주소로 매핑하는 DNS 레코드를 제공한다.

**IP 주소 획득 과정**
1. 요청 호스트 -> 로컬 DNS 서버
2. 로컬 DNS 서버 <-> 루트 DNS 서버
3. 로컬 DNS 서버 <-> TLD DNS 서버
4. 로컬 DNS 서버 <-> 책임 DNS 서버
5. 로컬 DNS 서버 -> 요청 호스트(브라우저 등등)

이 순서 말고도 재귀적으로 가능하다

1.요청 호스트 -> 로컬 DNS 서버 -> 루트 DNS 서버 -> TLD DNS 서버 -> 책임 DNS 서버
2.요청 호스트 <- 로컬 DNS 서버 <- 루트 DNS 서버 <- TLD DNS 서버 <-> 책임 DNS 서버

---
# CDN(Content Distribution Netword)
- 전세계의 사용자들에게 엄청난 양의 정적 데이터를 분배하는 문제를 해결하기 위해 대부분의 회사들은 CDN(Contents Distribution Network)를 사용한다.
  - 클라이언트가 데이터 센터로부터 혹은 클라우드로부터 먼 지점에 있더라도 네트워크 처리율을 높일수있다.
  - 장애 발생 확장을 막을 수 있다.
- CDN은 다수의 지점에 분산된 서버들을 운영하며, 비디오 및 다른 형태의 웹 컨텐츠 데이터의 복사본을 분산 서버에 저장한다
- 클라이언트와 가장 가까운 위치로 트래픽을 라우팅하여 인터넷 대기시간을 줄이고 전송 성능을 향상시킬 수 있다.
- 벌률적인 사항으로 국가별로 제한하는 기능이 필요하다.화이트리스트, 블랙 리스트를 지정하여 지리적으로 제한 가능하다.
- 서명된 URL, 서명된 쿠키 기능으로 컨텐츠를 보호할 수 있다.
- 엣지 로케이션은 데이터를 임시 저장할 수 있는 캐싱 기능을 만들 수 있다.

## 간단한 동작과정
ex) 사용자가 `NetCinema` 의 `KingCDN` 서버에 접속하는 과정 
1. 사용자 <-> `www.cinema.com` (`http://video.netcinema.com/123123`)
2. 사용자 -> `로컬 DNS 서버`(호스트 이름에서 `video` 감지 ) -> `NetCinema 책임 DNS 서버`
3. `로컬 DNS 서버` <- `NetCinema 책임 DNS 서버` (IP 대신 KingCDN 호스트 이름)
4. `로컬 DNS 서버` -> `KingCDN 책임 DNS 서버`
5. `로컬 DNS 서버` <- `KingCDN 책임 DNS 서버` (IP 주소)
6. 사용자 <- `로컬 DNS 서버`(IP 주소)
7. 사용자 <-> `KingCDN CDN` 서버
  
## 클러스터 선택 정책

### 지리적 기법
- 클라이언트의 LDNS 서버의 IP 주소를 바탕으로 지리정보 데이터베이스를 이용하여 LDNS의 IP 주소는 지리적으로 매핑될 수 있다.
- CDN은 IP주소를 기준으로 지리적으로 가장 가까운 클러스터를 할당하는 기법이다.