# 애플리케이션 계층

## 1. 네트워크 애플리케이션의 원리

### 클라이언트와 서버란?

두 프로세스 간의 통신 세션에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스를 클라이언트라하고, 세션을 시작하기 위해 접속을 기다리는 프로세스를 서버라고 한다.

### 클라이언트-서버 구조의 특징

- 항상 동작하고 있는 호스트를 **서버**라고 하고, 서버는 **클라이언트**의 요청을 받는다.
- 클라이언트는 서로 직접적으로 통신하지 않는다.
- 서버는 고정 IP를 갖는다.

### P2P 구조의 특징

- 항상 켜져있는 인프라스트럭처 서버에 거의 의존하지 않는다.
- 피어(peer)라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신한다.
- 각 피어들이 파일을 다른 피어들에게 분배함으로써 나타나는 **자가확장성**
- 클라이언트-서버 구조와는 다르게 높은 대역폭을 요구하지 않는다.

### 소켓을 이용한 통신

![](https://velog.velcdn.com/images/frost0807/post/6df28871-338b-48a5-a9e9-01bf2760b45f/image.jpg)

서로 다른 호스트간의 프로세스가 통신을 할 때는 **소켓**을 통해 메세지를 교환하는 방식으로 통신한다. 소켓은 호스트의 Application Layer와 Transport Layer간의 인터페이스이며, 애플리케이션과 네트워크 사이의 API라고 한다.

프로세스가 다른 호스트의 프로세스에 패킷을 보내기 위해서는 호스트의 주소와 수신하는 프로세스의 식별자가 필요하다. 호스트는 32비트로 이루어진 **IP주소**로 식별되며, 수신 프로세스는 **포트 번호**로 식별된다.

### 트랜스포트 프로토콜이 제공하는 서비스의 분류 기준

- 신뢰적 데이터 전송 : 송신한 데이터가 오류없이 수신 프로세스가 도착할 수 있게 하는 것을 뜻하며, 이를 보장하지 않는 서비스를 **손실 허용 애플리케이션**이라고 한다.

- 처리율 : 두 호스트간의 프로세스끼리 통신을 할 떄 송신 프로세스가 수신 프로세스로비트를 전달할 수 있는 비율을 처리율이라고 하는데, 특정한 처리율 요구사항을 갖는 애플리케이션을 **대역폭 민감 애플리케이션**이라고 하고 처리율 변동에 따라 유동적으로 이용할 수 있는 애플리케이션을 **탄력적 애플리케이션**이라고 한다.

- 시간 : 송신자가 내보내는 모든 비트가 일정시간 내에 도착할 수 있는지에 대한 여부를 뜻한다.

- 보안 : 송신 호스트에서 트랜스포트 프로토콜은 송신 프로세스가 전송하는 모든 데이터들을 암호화할 수 있다.

### 인터넷 프로토콜이 제공하는 서비스

#### TCP(Transmission Control Protocol)

- 연결 지향형 서비스 : 3-way handshake를 통해 두 프로세스의 소켓들을 연결한다. 메시지 전송을 마치면 4-way handshake로 연결을 끊는다.

- 신뢰적 데이터 전송 서비스 : 흐름제어, 오류제어, 혼잡제어를 통해 데이터를 오류 없이 올바른 순서로 전달한다.

#### UDP(User Datagram Protocol)

- 비연결형, 비신뢰적 데이터 전송 서비스

![](https://velog.velcdn.com/images/frost0807/post/d85d653d-289d-4c5b-9c55-a385a38ff274/image.jpg)

TCP와 UDP는 신뢰적 데이터 전송, 보안 2가지 분류에 따라 구분할 수 있는데 시간과 처리율은 언급되지 않았다. 두가지에 대한 보장없이도 오늘날의 인터넷에서 애플리케이션은 어느정도 잘 작동하고, 실시간성이 중요하면 UDP를 선택하는 식으로 설계할 수 있다.

## 2. 웹과 HTTP

### HTTP(Hyper Text Transfer Protocol)란?

서로 다른 호스트간의 통신은 HTTP 메세지를 교환하는 방식으로 이루어지는데, HTTP는 메세지의 구조 및 클라이언트와 서버가 메세지를 어떻게 교환하는지에 대해 정의하고 있다.

![](https://velog.velcdn.com/images/frost0807/post/7aefab89-0368-4903-be80-b088e534bfbb/image.jpg)

HTTP 는 TCP를 전송 프로토콜로 사용하는데, HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다. 연결되면 브라우저와 서버 프로세스는 각자의 소켓 인터페이스를 통해 TCP로 접속한다. 클라이언트가 소켓으로 HTTP 요청 메세지를 보내면 서버는 소켓에서 받고 HTTP 메세지를 처리한 후 다시 응답 HTTP 메세지를 소켓으로 보낸다. 클라이언트가 소켓에서 해당 HTTP 응답 메세지를 받으면 통신이 완료된다.

HTTP의 특징으로는 TCP를 사용하므로 신뢰적인 데이터 전송받으며, 비상태 프로토콜(stateless protocol이라는 것이 있다.

### 비지속 연결과 지속 연결

#### 비지속 연결

HTTP 1.0에서 사용되던 방식으로 각 요청마다 새로운 TCP 연결을 만든다.

각 요청의 진행 과정

1. HTTP 클라이언트가 80번 포트를 통해 해당 호스트의 서버로 TCP 연결을 시도한다.
2. HTTP 클라이언트는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메세지를 보낸다. 요청메세지에는 URI가 포함된다.
3. HTTP 서버는 1단계에서 설정된 연결 소켓을 통해 요청 메세지를 받고 저장장치로부터 해당 URI에 해당하는 객체를 추출한다. 그리고 HTTP 응답 메세지에 그 객체를 캡슐화하고 소켓을 통해 클라이언트로 보낸다.
4. 응답 메세지를 받은 클라이언트는 TCP에 연결 종료를 명령한다.
5. TCP 연결이 중단되고 클라이언트는 응답 메세지로부터 필요한 내용을 추출한다.
6. 요청이 있을때마다 1-5를 반복한다.

#### 비지속 연결의 단점

1. 각 요청마다 새로운 연결이 설정되어야 되어야 하므로 서버에 심각한 부담을 줄 수 있다.
2. 각 요청마다 TCP 연결 과정이 필요하므로 2 RTT의 시간을 필요로 한다.

#### 지속 연결

HTTP 1.1에서부터틑 지속 연결 방식을 사용한다. 지속 연결은 TCP 연결이 한번 설정되면 일정시간동안 사용되지 않을때까지 계속 연결되어 연속적으로 요청을 보낼 수 있다.

### HTTP 요청 메세지 포맷

![](https://velog.velcdn.com/images/frost0807/post/a100a3ed-6f90-40dc-897c-0875fbe55d1f/image.jpg)

```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

HTTP 요청 메세지는 일반적으로 위와 같은 형식을 따른다.

맨 윗줄의 방식, URL, 버전이 들어가는 부분을 **요청 라인**이라고 하며, 그 다음줄부터 헤더 필드 이름과 값들이 들어가는 **헤더 라인**, 그리고 헤더라인이 끝나면 비어있는 줄을 한 줄 두고 그 다음줄부터 body가 들어가게 된다.

방식에는 GET, POST, HEAD, PUT, PATCH, DELETE 등이 있으며, 이 중 GET 방식은 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용한다. 헤더 라인 중 Host는 객체가 존재하는 호스트를 명시하고 있으며, Connection은 지속 연결을 사용할지 말지에 대한 정보를 명시하고 있다. User-agent는 요청은 보낸 브라우저의 타입을, 마지막으로 Accept-language는 클라이언트에서 원하는 언어에 대한 정보이다.

body의 경우에는 GET 요청의 경우에는 비어있는 상태지만 POST 요청의 경우에는 유의미한 내용이 들어가게 된다.

### HTTP 응답 메세지 포맷

![](https://velog.velcdn.com/images/frost0807/post/01caba4c-4824-4184-a630-e212a7677878/image.jpg)

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(데이터 데이터 데이터 데이터 데이터 ...)
```

HTTP 응답 메세지는 일반적으로 위와 같은 형식을 따른다.
맨 윗줄을 상태라인, 그 다음줄부터를 헤더 라인 그리고 헤더라인이 끝나면 빈 한 줄을 두고 body가 들어가게 된다.

#### HTTP 상태코드

- 200 OK : 요청이 성공했고, 정보가 응답으로 보내졌다.
- 201 Created : 요청한 자원이 성공적으로 생성되었다.
- 301 Moved Permanently : 요청 객체가 영원이 디오되었다. 리다이렉션 할 URL은 응답 메시지의 Location에 포함
- 400 Bad Request : 서버가 요청을 이해할 수 없다는 일반 오류코드
- 401 Unauthorized : 요청이 서버의 해당 자원에 대한 인증에 실패했다.
- 403 Forbidden : 401과 비슷하지만 인증된 사용자의 권한이 요구에 못미쳐 접근이 불가한 상황
- 404 Not Found : 요청 문서가 서버에 존재하지 않는다.
- 500 Internal Servel Error : 해당 요청에 대해 서버 내부적으로 알 수 없는 오류가 발생했다.
- 505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.

#### 응답 헤더 라인

- Conncetion : 해당 응답을 보내고 TCP 연결을 유지할 지 말지에 대한 헤더
- Date : 서버가 해당 응답을 전송한 날짜와 시간을 나타낸다.
- Server : 메시지가 어떤 타입의 서버에 의해 만들어졌는지를 나타낸다.
- Last-Modified : 객체가 생성되거나 마지막으로 수정된 날짜와 시간을 나타낸다. 이걸 기준으로 캐싱을 한다.
- Content-Length : 송신되는 객체의 바이트 수를 나타낸다.
- Content-Type : 응답 객체가 어떤 형식인지를 나타낸다.(text/html, application/json 등)

### 쿠키

기본적으로 HTTP는 stateless로 동작하므로 사용자에 따라 다르게 서비스를 제공하는게 어려움이 있다. 이를 해결하기 위에 HTTP는 쿠키를 사용한다.

![](https://velog.velcdn.com/images/frost0807/post/a18842e4-9e5d-47bf-a792-c9844bd0c2b8/image.jpg)

1. 클라이언트에서 서버로 요청을 보낸다.
2. 서버는 해당 요청을 하는 사용자를 식별하기 위한 코드를 Set-cookie 헤더에 실어서 응답과 함께 클라이언트로 보낸다.
3. 응답을 받은 클라이언트는 Set-cookie 헤더에 있는 내용을 브라우저의 cookie에 저장하고 해당 브라우저는 서버에 요청을 보낼 때마다 해당 쿠키를 포함시킨다.
4. 서버는 쿠키를 확인해 사용자를 식별하고 해당 사용자에게 맞는 서비스를 제공할 수 있게 된다.

이러한 쿠키는 식별된 사용자의 인터넷 사용 기록을 바탕으로 맞춤형 서비스를 제공할 수 있다.

### 웹 캐싱

![](https://velog.velcdn.com/images/frost0807/post/4e5269d1-bcfd-475a-b1fd-dbb6fef2ec11/image.jpg)

웹 캐시는 origin Web server를 대시하여 HTTP 요구를 충족시키는 네트워크 개체다.

응답시간 감소, 기점 서버로의 트래픽 감소를 장점으로 들 수 있다.

#### 웹 캐싱의 진행과정

1. 브라우저가 캐시 서버와 TCP 연결을 설정하고 HTTP 요청을 보낸다.
2. 캐시 서버는 유효한 해당 객체를 자신이 가지고 확인하고, 가지고 있으면 HTTP 응답 메세지와 함께 객체를 전송한다.
3. 웹 캐시가 객체를 가지고 있지 않다면, 캐시 서버는 기점 서버와 TCP 연결을 설정하고 해당 객체에 대한 HTTP 요청 메세지를 보내고 기점 서버는 해당 객체에 대한 응답을 캐시 서버로 보낸다.
4. 캐시 서버는 기점 서버의 응답을 저장하고 해당 객체를 다시 클라이언트 브라우저에게 HTTP 응답 메시지로 보낸다.

CDN을 통해 캐시 서버는 인터넷에서 중요한 역할을 하고 있다.

### 조건부 GET

그렇다면 해당 캐시서버의 객체가 기점 서버에서는 이미 수정되었는지 어떻게 알 수 있을까?

1. 캐시에 저장되지 않은 객체를 브라우저 클라이언트가 캐시 서버에 요청한다.
2. 캐시는 저장본이 없으므로 서버에 다시 HTTP 요청 메세지를 보내고 서버는 HTTP 응답 메세지를 보내면서 Last-Modified 헤더에 해당 객체가 마지막으로 생성되었거나 수정된 날짜와 시간을 담아 보낸다.
3. 이 객체는 캐시 서버에 저장되고 다시 캐시 서버는 클라이언트에 해당 응답을 보내는데
4. 이 후 해당 객체에 대해 다시 클라이언트가 캐시 서버에 요청을 보낼 때는 If-modified-since 라는 헤더에 날짜와 시간을 담아서 HTTP 요청 메세지로 보낸다.
5. 요청 메세지를 받은 캐시 서버는 해당 날짜와 시간이후로 객체가 수정되었는지 기점 서버로 다시 요청을 보내게 되고 기점 서버는 이를 대조해 변경 되었으면 갱신된 객체를, 아니라면 빈 몸체를 가진 HTTP 응답 메세지를 보낸다.
6. 응답을 받은 캐시 서버는 응답 헤더에 304 Not Modified라면 저장되어 있던 객체를 그대로 보내고 아니라면 갱신된 객체를 저장하고 복사해서 보낸다.

### HTTP/2

#### 프레이밍

HTTP 1.1은 여러개의 객체를 한번에 보낼 때 처리가 느린 데이터 때문에 **Head Of Line** 블로킹 문제가 발생할 수 있었다. 이러한 문제를 기존에는 최대 6개의 TCP 연결을 열여서 해결했지만 HTTP 2.0에서는 이러한 병렬 TCP 연결을 줄이거나 제거하는걸 목표로 삼았다. 이를 위해 프레이밍이라는 기법을 사용했는데, 요청의 객체들을 작은 프레임 단위로 나누고 바이너리 인코딩을 거쳐 순서에 상관없이 보내는 방법이다. 이렇게 해서 사용자는 지연 시간이 짧아졌다고 느끼게 되었다.

#### 메세지 우선순위화 및 서버 푸싱

HTTP 2 버전의 또다른 특징으로는 메세지 우선순위화가 있는데, 프레임마다 우선순위를 부여해 중요한 객체를 상대적으로 빠르게 전송할 수 있게 했다. 그리고 클라이언트의 요청에 대해 연관된 여러개의 응답을 보낼 수 있게 해주는 서버 푸싱 기법도 등장했다.

### HTTP/3

새로운 트랜스포트 프로토콜이 QUIC 위에서 작동하도록 설계된 새로운 HTTP 프로토콜

## 4. DNS: 인터넷의 디렉터리 서비스

DNS는 직관적인 호스트 이름을 컴퓨터가 이해가 쉬운 IP 주소로 변환해주는 디렉터리 서비스이다. DNS서버들은 계층구조로 구현된 분산 데이터베이스이고, 호스트가 분산 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜이다.

### DNS 질의과정

1. 브라우저가 URL로부터 호스트 이름을 추출하고 그 호스트 이름을 DNS 애플리케이션의 클라이언트 측에 넘긴다.
2. DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하는 질의를 보낸다.
3. DNS 클라이언트는 호스트 이름에 대한 IP 주소를 가진 응답을 받게 된다.
4. 브라우저가 DNS로부터 IP 주소를 받으면, 브라우저는 해당 IP 주소와 그 주소의 80번 포트에 위치하는 HTTP 서버 프로세스로 TCP 연결을 초기화한다.

### DNS의 추가 기능

- 호스트 앨리어싱(host aliasing) : 호스트 이름이 복잡할 경우에 해당 호스트는 하나 이상의 별명을 가질 수 있다. 예를 들어, relay1.west-coast.enterprise.com 과 같은 호스트 이름이 있을 때 enterprise.com 이나 www.enterprise.com 같은 2개의 별칭을 가질 수 있다. 이 떄 relay1.west-coast.enterprise.com 을 **정식 호스트 이름** 이라고 한다.

- 메일 서버 앨리어싱(mail server aliasing) : 복잡한 메일 서버의 호스트 이름을 간단한 별칭으로 호출할 수 있다.

- 부하 분산 : 서버의 부하가 클 것으로 예상될 떄, 호스트 이름 1개에 대해서 여러개의 IP 주소를 할당하고, 해당 호스트이름에 요청이 들어올 때 마다 IP 주소를 순환식으로 보내주는 방식이다.

### DNS의 계층구조와 질의 과정

![](https://velog.velcdn.com/images/frost0807/post/21225bd7-de68-45ed-8381-16f6ce2dc8e2/image.jpg)

- 루트 DNS 서버 : 1000개 이상의 루트 서버 인스턴스가 전 세계에 흩어져 있으며, 루트 서버들은 13개의 다른 루트 서버 복사체이고, 12개의 다른 기관에서 관리되며, 인터넷 할당 번호 관리기관에 의해 조정된다. 루트 네임 서버는 TLD 서버의 IP 주소들을 제공한다.

- 최상위 레벨 도메인(TLD) 서버 : com, org, net, edu, gov 같은 상위 레벨 도메인과 kr, uk, fr, ca, jp 같은 모든 국가의 상위 레벨 도메인에 대한 TLD 서버가 있다. TLD 서버는 책임 DNS 서버에 대한 IP 주소를 제공한다.

- 책임 DNS 서버 : 인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 이름을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야한다. 기관의 책이므 DNS 서버는 이 DNS 레코드를 갖고 있다.

![](https://velog.velcdn.com/images/frost0807/post/260943f9-a547-44d0-b263-43262e3237c0/image.jpg)

cse.nyu.edu가 gaia.cs.umass.edu에 대해 질의한다고 가정해보자

1. cse.nyu.edu가 먼저 자신의 로컬 DNS 서버 dns.nyu.edu에게 DNS 질의 메세지를 보낸다.
2. 로컬 DNS 서버는 그 질의 메시지를 루틑 DNS 서버에게 전달한다.
3. 루트 DNS 서버는 edu를 인식하고, edu에 대한 책임을 가진 TLD 서버의 IP 주소 목록을 로컬 DNS 서버에게 보낸다.
4. 로컬 DNS 서버는 질의 메세지를 TLD 서버로 보낸다.
5. TLD 서버는 umass.edu를 인식하고 dns.umass.edu로 이름 지어진 책임 DNS 서버의 IP 주소로 응답한다.
6. 로컬 DNS 서버는 직접 dns.umass.edu로 질의 메세지를 다시 보내고, gaia.cs.umass.edu의 IP 주소로 응답한다.

### DNS 캐싱

웹 캐싱과 비슷한 방식인데, 질의 사슬에서 DNS 서버가 DNS 응답을 받으면 그것을 로컬 메모리에 저장해 다음번에 같은 질의가 오면 저장되어 있는 응답을 보내주는 식이다.

### DNS 레코드

DNS 분산 데이터베이스를 구현한 DNS 서버들은 **자원 레코드**를 저장하는데, 이 자원 레코드는 다음과 같은 튜플로 구성되어 있다.

`(Name, Value, Type, TTL)`

TTL은 자원 레코드의 생존 기간(time to live)이다.

| Type  | Name                         | Value                                                                        |
| ----- | ---------------------------- | ---------------------------------------------------------------------------- |
| A     | 호스트 이름                  | IP 주소                                                                      |
| NS    | 도메인                       | 도메인 내부 호스트에 대한 IP 주소를 얻을 수 있는 책임 DNS 서버의 호스트 이름 |
| CNAME | 별칭 호스트 이름             | 정식 호스트 이름                                                             |
| MX    | 메일 서버의 별칭 호스트 이름 | 메일 서버의 정식 호스트 이름                                                 |

### DNS 메세지

![](https://velog.velcdn.com/images/frost0807/post/845719bf-c376-40c0-8b5a-dbea5c61509d/image.jpg)

DNS의 요청과 응답 메세지는 위 그림과 같은 형태를 띄고있다.

- 처음 12바이트는 헤더 영역으로, 첫 필드는 질의를 식별하는 2바이트의 숫자이고, 이 식별자는 질의에 대한 응답 메세지에 복사되어 클라이언트가 보낸 질의와 수신된 응답 간의 일치를 식별하게 한다. 플래그 필드에는 질의/응답 플래그, 책임 플래그, 재귀 요구 플래그 등이 있다. 그 아래로 4개의 '개수'필드가 있는데 이것들은 헤더 다음에 오는 데이터 영역의 네 가지 타입의 발생 횟수를 나타낸다.

- 질문 영역 : 현재 질의에 대한 정보를 포함한다. 질의되는 이름을 포함하는 이름 필드와,이름에 대해 문의되는 질문 타입을 나타내는 타입 필드를 포함한다.
- 답변 영역 : 원래 질의된 이름에 대한 자원 레코드를 포함한다. 호스트 이름은 여러 개의 IP 주소를 가질 수 있으므로 응답으로 여러 개의 RR을 보낼 수 있다.
- 책임 영역 : 다른 책임 서버의 레코드를 포함한다.
- 추가 영역 : 다른 도움이 되는 레코드를 포함하고 있다.

## 7. 소켓 프로그래밍

### UDP

![](https://i.ibb.co/cyW1Rhq/Kakao-Talk-20230116-181214994-02.jpg)

#### 진행과정

- 클라이언트

1. 클라이언트에서 서버의 호스트 이름 혹은 IP주소와 포트번호를 통해 어디로 요청을 보낼 지 결정한다.
2. 클라이언트의 소켓을 생성하고 보낼 메세지를 생성한다.
3. 메세지를 바이트 타입으로 인코딩 한 다음 목적지 주소를 붙여서 소켓으로 보낸다.
4. 서버에서 응답이 오면 디코딩하고 소켓을 닫는다.

- 서버

1. 소켓을 생성하고 해당 프로세스의 포트번호를 소켓에 할당한다.
2. 메세지가 오기를 기다리다가 메세지가 도착하면 디코딩 한다.
3. 해당 요청에 대한 응답을 다시 바이트로 인코딩해 클라이언트 주소와 함께 소켓으로 보낸다.

### TCP

![](https://i.ibb.co/pwvm726/Kakao-Talk-20230116-181214994.jpg)

TCP 소켓의 작동방식은 UDP와는 좀 다르다. TCP 연결에서 서버에는 클라이언트의 초기접속을 위한 환영 소켓이 존재하며, 실제 데이터를 주고 받는 소켓은 따로 있다.

![](https://i.ibb.co/7CVq3vy/Kakao-Talk-20230116-181214994-01.jpg)

#### 진행과정

- 클라이언트

1. 클라이언트에서 서버의 호스트 이름 혹은 IP주소와 포트번호를 통해 어디로 요청을 보낼 지 결정한다.
2. 클라이언트의 소켓을 생성하고 서버의 connectionSocket과의 3-way handshake를 통해 연결을 설정한다.
3. 메세지를 바이트 타입으로 인코딩 한 다음 소켓을 통해 TCP 연결로 보낸다
4. 서버에서 응답이 오면 디코딩하고 작업과 요청이 모두 끝났으면 소켓을 닫는다.

- 서버

1. 소켓을 생성하고 해당 프로세스의 포트번호를 소켓에 할당한다.
2. 클라이언트가 TCP 연결을 설정하려고 하면 서버는 connection 소켓을 생성하고 handshaking을 해 연결을 완료한다.
3. 해당 요청에 대한 응답을 인코딩해 소켓을 통해 TCP 연결로 보내고 connection 소켓을 닫는다.

---

질문거리

- **(면접)** 서비스를 Stateless하게 설계하면 어떤 장점과 단점이 있을까요?
- TransportProtocol 이 제공하는 서비스의 분류기준에는 어떤것들이 있을까요?
- TCP와 UDP의 차이에 대해서 설명해주세요
- UDP를 사용해볼만한 애플리케이션에는 어떤것들이 있을까요?
- **(면접)** 3-way handshake는 어떤식으로 이루어지나요?
- **(면접)** 4-way handshake는 어떤식으로 이루어지나요?
- HTTP 요청 메세지의 첫번째 줄에는 어떤것들이 들어가나요?
- Connection 헤더의 역할이 뭔가요?
- Last-Modified 헤더의 역할이 뭔가요?
- **(면접)** HTTP 상태코드의 번호대 별 차이에 대해 알고있는지
- **(면접)** HTTP 상태코드 301과 302의 차이가 뭔가요?
- **(면접)** HTTP 상태코드 401과 403의 차이가 뭔가요?
- 쿠키가 뭔가요?
- 쿠키가 어떤식으로 작동하는지 설명해주세요
- 웹 캐싱에 대해서 설명해주세요
- 웹 캐싱을 사용해서 얻는 이점이 뭔가요?
- 웹 캐싱을 사용해서 문제가 발생할 수 있는 경우에는 어떤게 있을까요?
- HOL Blocking이 뭔가요?
- HTTP 1.1 버전과 2.0 버전의 차이점에 대해서 설명해주세요
- DNS가 뭔가요?
- DNS의 부하분산(DNS 라운드 로빈)이 뭔가요?
- DNS의 계층구조는 어떻게 되어있나요?
- **(면접)** 인터넷창에 www.google.com을 쳤을때 사용자 호스트와 구글 서버 간에 어떤 일들이 일어나는지 네트워크 관점에서 설명해주세요
- DNS 레코드가 뭔가요?
- DNS 레코드 튜플의 Type이 CNAME이라면 Name과 Value에는 어떤값이 들어가나요?
- DNS 메세지는 뭔가요?
